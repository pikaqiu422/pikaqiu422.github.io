<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JAVA从零单排——难题错题篇</title>
    <link href="/2020/03/25/JAVA%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/"/>
    <url>/2020/03/25/JAVA%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA从零单排——语言学习篇</title>
    <link href="/2020/03/25/JAVA%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <url>/2020/03/25/JAVA%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++从零单排——语言学习篇</title>
    <link href="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <url>/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++从零单排——难题错题篇</title>
    <link href="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/"/>
    <url>/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h4 id="以下题目均来自于牛客网https-www-nowcoder-com-intelligentTest"><a href="#以下题目均来自于牛客网https-www-nowcoder-com-intelligentTest" class="headerlink" title="以下题目均来自于牛客网https://www.nowcoder.com/intelligentTest"></a>以下题目均来自于牛客网<a href="https://www.nowcoder.com/intelligentTest" target="_blank" rel="noopener">https://www.nowcoder.com/intelligentTest</a></h4><h4 id="我们的口号是："><a href="#我们的口号是：" class="headerlink" title="我们的口号是："></a><em>我们的口号是：</em></h4><h1 id="每天十道，提神醒脑！"><a href="#每天十道，提神醒脑！" class="headerlink" title="每天十道，提神醒脑！"></a><font face="华文行楷">每天十道，提神醒脑！</font></h1><h4 id="Date-2020-3-25"><a href="#Date-2020-3-25" class="headerlink" title="Date:2020-3-25"></a><em>Date:2020-3-25</em></h4><h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-25-1.png" srcset="/img/loading.gif" alt></p><p>考察点：数组名作为指针的时候是一个常量，而指针是一个变量。</p><h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-25-2.png" srcset="/img/loading.gif" alt></p><p>不管基类析构函数加不加virtual，只要是声明的是基类的指针，即使实际指向的实例是派生类的，也不会调用派生类的析构方法。</p><p>不管基类析构函数加不加virtual，只要是声明的是派生类的指针，并且实际指向的实例是派生类的，会先调用派生类的析构方法，然后级联调用父类的析构方法。参见：</p><pre><code class="c++">#include&lt;stdio.h&gt;class A{    public:    A(){ printf(&quot;A&quot;);}    ~A(){ printf(&quot;~A&quot;);}};class B: public A{    public:        B(){ printf(&quot;B&quot;);}        ~B(){ printf(&quot;~B&quot;);}};    int main(){    B* c = new B[2];    delete[] c;    return 0;}</code></pre><p>输出<strong>ABAB<del>B</del>A<del>B</del>A</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>编程语言学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>皮卡丘422的第一篇个人博客</title>
    <link href="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="皮卡丘422的第一篇个人博客"><a href="#皮卡丘422的第一篇个人博客" class="headerlink" title="皮卡丘422的第一篇个人博客"></a><font face="楷体"><center>皮卡丘422的第一篇个人博客</center></font></h1><h4 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h4><p>如果有人跟十年前的我说，二十多岁是人生最难的十年，我肯定不屑一顾。小时候的自己就觉得成年人有多么多么好，多么多么自由。可就是太自由了，人生才容易失去方向。学生思维的三大局限，或者说是人性的弱点——<strong><em>终点型思维，秘籍型思维和空杯型思维</em></strong>，（理论参考知乎用户柴桑）而现在的我，对<strong>终点型思维</strong>有了更深刻的理解。</p><p>第二次与北大失之交臂，可笑的单科线，成了压死骆驼的最后一根稻草。被迫开始考虑找工作，开始研究技术，开始不断充电学习。蓦然回首，我突然发现自己竟然早已陷入了这样的思维之中很深很深。为什么要考北大呢？一半的名校梦，一半的“北大研究生出来就能怎样怎样”。<strong>若不是迫不得已转向的招聘一事给了我当头一棒，我不知还要沉浸在这种思想中多久</strong>。诚然，一所名校的高学历不仅代表着高智商，也往往代表着高能力。不可否认的是，从名校毕业的学生也往往是同龄人里最优秀的，但这份优秀不是源自于名校身份赋予了他多少，而是在于他在名校的环境中学到了多少。这里提名我的大学寝室长，目前就读于哈尔滨工业大学深圳研究院的cs专硕。从毕业后这一年中间歇性的交流之中，我有理由相信，也是毫不夸张的说，他在哈工的这一年，比他在电子科大的四年，包括大四上的考研，所付出的全部还要多很多。他日常会在寝室群里说，同门了，同学了都太厉害了，自己差的很远，得追。至于后面哪怕是疫情阶段，无法返校，他在家的学习生活都是7-12-7。我不知道他都具体学到了什么，但有一点我可以确信，就是他知道了人生要努力，并在努力的路上不断地前行着。</p><p>或许现在意识到这点还不晚。虽然从古至今有太多的文学作品劝人努力，催人奋进，但真的只有一个人切身走到那一步了，无路可退了，才能真的意识到<strong>努力的重要性</strong>。我从小就是一个靠着天赋和老师推着走的学生。娱乐的手段千千万，而学习之路就是完任务。当然，这也局限于家庭、环境所给我带来的学习局限性，我不知道什么是编程，什么是算法，除了语数外政史地生，还有什么东西是一个人的成长应该要学的。老师会跟你说，坚持到大学就解放了；父母会跟你说，学习这条路就是把学校的东西学好。所以我的大学生活，和很多人一样，没有挂科，也没啥荣誉，唯一奋斗过的一段时光，就是大二组队争取了一个大学生建模的省一。作为一个cs科班出身的学生，在大学毕业码过的代码也不过千余行，想想也是可笑。至于走到如今这个时间点，点开许多同龄人的博客、简历，才知道自己四年时间被拉开了多少个身位。</p><p>努力不是头悬梁，锥刺股那么夸张，而是在一个<strong>该学习的时间段去学习，该奋斗的时间段去奋斗</strong>，这点，是我这两年考研经历所教会我的全部。人生也不是向着终点前进，而是一场起点不一样的长跑，跑得远的不代表了胜利，跑得久的才是。<em>这里多嘴一句，教育是个奢侈品，对于任何家庭都是。它贵在的，不仅是昂贵的学区房、一线城市户口、优质的教育资源，更是家长能带给子女的眼界，能否做到以身作则的表率。如果家长嘴里只有：把学校的东西学会了，就够了；小孩子没有隐私权，我说让你干什么，你就干什么；什么是编程，什么是宇宙，什么是量子力学，我不懂，你自己看去；看电视剧是大人的权力，我们才能看，你去学习去，我们老了，学不动了；养儿防老，不孝有三，无后为大等等。那么我请您再好好思考一下，您真的要生这个孩子吗？如果要生，那么在孩子的成长过程中，当你提到别人家的小孩如此怎样的时候，当你望子成龙，望女成凤的时候，请你闭嘴，你没有资格随便买了一张彩票，就要求中大奖。自己都活不明白的人，生小孩改变不了自己的人生，还只会连累到孩子，贫贱夫妻百事哀，想改变人生，只能靠自己。</em></p><p>第一篇博文唠唠叨叨了很多，再加上近期经历得很多，思考了很多，对于教育，对于人生。这里面存在很多我个人的局限性，也和我的经历息息相关。偷懒的兔子，已经在路边睡了好多年，虽然现在亡羊补牢还为时未晚，但必须要跑起来了。立一个flag，博客的事，从今天开始，这次一定，坚持下去。不管未来的路我会怎么走，<strong><em>奋进是我的主旋律！</em></strong></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/labi.jpg" srcset="/img/loading.gif" alt></p><hr><h2 id="先从leetcode算法题的学习开始："><a href="#先从leetcode算法题的学习开始：" class="headerlink" title="先从leetcode算法题的学习开始："></a><font face="楷体">先从leetcode算法题的学习开始：</font></h2><p><em>熟练掌握算法题，不仅要学会算法中的思想，更要多练，这是一个熟能生巧的过程。</em></p><p><em>下面题目均来源于<a href="https://leetcode-cn.com" target="_blank" rel="noopener">https://leetcode-cn.com</a></em></p><h4 id="类别一：数组的简单应用"><a href="#类别一：数组的简单应用" class="headerlink" title="类别一：数组的简单应用"></a><em>类别一：数组的简单应用</em></h4><h5 id="1、两数之和（easy）"><a href="#1、两数之和（easy）" class="headerlink" title="1、两数之和（easy）"></a>1、两数之和（easy）</h5><p><em>题目描述：</em></p><p>给定一个整数数组 <code>nums</code> 和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc1.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>最简单，也是最直接的想法，先选定数组中的一个数，再通过遍历取得数组中剩下的另一个数。由于答案唯一，只要如此遍历一遍，一定能找到答案。但这样的做法问题在于时间复杂度很高,达到了<em>O</em>（n^2），当数组给定量很大时，用时会非常的高。</p><p>这里我们考虑利用c++的STL提供的<strong>map</strong>关联容器进行解答。根据百度百科中的描述，map提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可以称为该关键字的值）的数据处理能力，其内部是一个自建的红黑树（这个知识点之后一定要学习一下），这样在进行数据查找的时候，时间复杂度就能降到<em>O</em>（1）的水平，也就是我们所说的哈希查找。</p><p>判断一个数据是否在map中，我们可以通过两种形式进行判断，</p><p><code>map.find(target) != m.end();</code>  这里是判断map的迭代器是否走到了最后，即map中不存在<code>target</code>。</p><p><code>map.count(target) == 1;</code></p><p>所以据此的解决方案即为：依次将数组元素读入map中，并将第二项元素设置为所对应数组中元素位置编号。在读入之前判断<code>target-nums[i]</code>一项是否存在，这样可以消除重复判断新读入的元素而造成重复利用数组中的同样元素。当然每道题都要考虑边界条件，本题要考虑这样的一对整数不存在，需要返回空数组。</p><p><em>最终代码：</em></p><pre><code class="c++">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        map&lt;int, int&gt; m;        for(int i = 0; i &lt; nums.size(); i++){            if(m.find(target - nums[i]) != m.end())                return {m[target - nums[i]], i};            m[nums[i]] = i;        }        return {};    }</code></pre><hr><h4 id="类别二：链表的简单应用"><a href="#类别二：链表的简单应用" class="headerlink" title="类别二：链表的简单应用"></a><em>类别二：链表的简单应用</em></h4><h5 id="2、两数相加-medium"><a href="#2、两数相加-medium" class="headerlink" title="2、两数相加(medium)"></a>2、两数相加(medium)</h5><p><em>题目描述：</em></p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储一位数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc2.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>链表与顺序表的区别在于，链表的每一个结点信息，必须依靠上一个结点信息才能获得。</p><p><em>最终代码</em></p><pre><code class="c++">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {        ListNode*  T = new ListNode(-1);        ListNode* head = T;        bool count = false;        while(l1 != NULL || l2 != NULL){            int  sum = 0;            if(l1 != NULL){                sum = sum + l1-&gt;val;                l1 = l1-&gt;next;            }            if(l2 != NULL){                sum = sum + l2-&gt;val;                l2 = l2-&gt;next;            }            if(count){                sum++;            }            T-&gt;next = new ListNode(sum%10);            T = T-&gt;next;            count = sum &gt; 9 ?true:false;        }        if(count){            T-&gt;next = new ListNode(1);        }        return head-&gt;next;    }</code></pre><hr><h4 id="类别三：字符串的简单应用"><a href="#类别三：字符串的简单应用" class="headerlink" title="类别三：字符串的简单应用"></a><em>类别三：字符串的简单应用</em></h4><h5 id="3、无重复字符的最长子串-medium"><a href="#3、无重复字符的最长子串-medium" class="headerlink" title="3、无重复字符的最长子串(medium)"></a>3、无重复字符的最长子串(medium)</h5><p><em>题目描述：</em></p><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc3.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p><em>最终代码</em></p><pre><code class="c++">int lengthOfLongestSubstring(string s) {        int l = s.length();        if(l == 0)            return 0;        int p = 0;        int max = 1;        for(int i = 0; i &lt; l; i++){            for(int j = p; j &lt; i; j++){                if(s[j] == s[i]){                    p = j + 1;                }            }            int count = i - p + 1;            if(count &gt; max)                max = count;        }        return max;    }</code></pre><h5 id="5、最长回文子串-medium"><a href="#5、最长回文子串-medium" class="headerlink" title="5、最长回文子串(medium)"></a>5、最长回文子串(medium)</h5><p><em>题目描述：</em></p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc5.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p><em>最终代码</em></p><pre><code class="c++">int ifcircle(string&amp; s, int i, int j){        int L = i, R = j;        if(s[L] != s[R])            return 0;        while(s[L] == s[R] &amp;&amp; L &gt; 0 &amp;&amp; R &lt; s.length()-1){            L--;            R++;        }        if(s[L] == s[R])            return R - L + 1;        else             return R - L - 1;    }    string longestPalindrome(string s) {        int n = s.length();        int len1, len2, len;        int begin = 0, end = 0, max = 0;        for(int i = 0; i &lt; n; i++){            len1 = ifcircle(s, i, i);            len2 = ifcircle(s, i, i+1);            len = len1 &gt; len2 ?len1:len2;            if(len &gt; max){                if(len % 2){                    begin = i - (len - 1)/2;                    end = i + (len - 1)/2;                }                else{                    begin = i - (len - 1)/2;                    end = i + len / 2;                }                max = len;            }        }        if(max % 2)            return s.substr(begin, max);        else            return s.substr(begin, max);    }</code></pre><hr><h4 id="类别四：二分查找的应用"><a href="#类别四：二分查找的应用" class="headerlink" title="类别四：二分查找的应用"></a><em>类别四：二分查找的应用</em></h4><h5 id="4、寻找两个有序数组的中位数-hard"><a href="#4、寻找两个有序数组的中位数-hard" class="headerlink" title="4、寻找两个有序数组的中位数(hard)"></a>4、寻找两个有序数组的中位数(hard)</h5><p><em>题目描述：</em></p><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code>和 <code>nums2</code>不会同时为空。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc4.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p><em>最终代码</em></p><pre><code class="c++">double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        if(nums1.size() &gt; nums2.size())            return findMedianSortedArrays(nums2, nums1);        int m = nums1.size();        int n = nums2.size();        int a1 = 0, a2 = m;        int mid1, mid2, half = (m + n + 1)/2;        while(a1 &lt;= a2){            mid1 = (a1 + a2)/2;            mid2 = half - mid1;            if(mid1 &lt; a2 &amp;&amp; nums2[mid2-1] &gt; nums1[mid1]){                a1 = mid1 + 1;            }            else if(mid1 &gt; a1 &amp;&amp; nums1[mid1-1] &gt; nums2[mid2]){                a2 = mid1 - 1;            }            else{                int maxl = 0;                if(mid1 == 0)                    maxl = nums2[mid2-1];                else if(mid2 == 0)                    maxl = nums1[mid1-1];                else{                    maxl = nums1[mid1-1] &gt; nums2[mid2-1] ?nums1[mid1-1]:nums2[mid2-1];                }                if((m + n) % 2 == 1)                    return maxl;                int maxr = 0;                if(mid1 == m)                    maxr = nums2[mid2];                else if(mid2 == n)                    maxr = nums1[mid1];                else                    maxr = nums1[mid1] &lt; nums2[mid2] ?nums1[mid1]:nums2[mid2];                return (maxl + maxr) / 2.0;            }        }        return 0.0;    }</code></pre><hr><h4 id="类别四：二分查找的应用-1"><a href="#类别四：二分查找的应用-1" class="headerlink" title="类别四：二分查找的应用"></a><em>类别四：二分查找的应用</em></h4><h5 id="4、寻找两个有序数组的中位数-hard-1"><a href="#4、寻找两个有序数组的中位数-hard-1" class="headerlink" title="4、寻找两个有序数组的中位数(hard)"></a>4、寻找两个有序数组的中位数(hard)</h5><p><em>题目描述：</em></p><p><em>示例：</em></p><p><em>思考：</em></p><p><em>最终代码</em></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法的学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
