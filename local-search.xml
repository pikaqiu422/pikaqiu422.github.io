<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>校园招聘面试--深信服</title>
    <link href="/2020/03/27/%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E9%9D%A2%E8%AF%95-%E6%B7%B1%E4%BF%A1%E6%9C%8D/"/>
    <url>/2020/03/27/%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E9%9D%A2%E8%AF%95-%E6%B7%B1%E4%BF%A1%E6%9C%8D/</url>
    
    <content type="html"><![CDATA[<p>2020-3-28日上午11：00将参加<strong>深信服公司C/C++开发工程师</strong>职位电话面试（校招）</p><h3 id="面试前相关面试经验查询与准备："><a href="#面试前相关面试经验查询与准备：" class="headerlink" title="面试前相关面试经验查询与准备："></a><strong><em>面试前相关面试经验查询与准备：</em></strong></h3><p>资源一：来源CSDN博主「青龙指引你」<a href="https://blog.csdn.net/xp731574722/article/details/82868560" target="_blank" rel="noopener">https://blog.csdn.net/xp731574722/article/details/82868560</a></p><p>资源二：来源CSDN博主「Secur17y」<a href="https://blog.csdn.net/Secur17y/java/article/details/100122199" target="_blank" rel="noopener">https://blog.csdn.net/Secur17y/java/article/details/100122199</a></p><h4 id="C-C-语言基础："><a href="#C-C-语言基础：" class="headerlink" title="C/C++语言基础："></a><em>C/C++语言基础：</em></h4><h5 id="1-new和malloc的区别？"><a href="#1-new和malloc的区别？" class="headerlink" title="1.new和malloc的区别？"></a>1.new和malloc的区别？</h5><p><code>new/delete</code>是C++操作符，<code>malloc/free</code>是库函数<br><code>new</code>自行计算需要空间的大小，<code>malloc</code>需要指定大小<br><code>new</code>从<strong>自由存储区</strong>分配内存，<code>malloc</code>从<strong>堆</strong>上分配内存<br><code>new</code>在分配内存时调用构造函数,<code>delete</code>在释放内存时调用析构函数，<code>malloc</code>只分配内存<strong>不做初始化</strong><br>在分配内存失败时,<code>new</code>抛出<code>bac_alloc</code>异常，<code>malloc</code>则返回<code>NULL</code></p><h5 id="2-strcpy与memcpy的区别"><a href="#2-strcpy与memcpy的区别" class="headerlink" title="2.strcpy与memcpy的区别?"></a>2.strcpy与memcpy的区别?</h5><p>1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。<br>2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。<br>3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p><h5 id="3-C如何使用cpp文件的函数"><a href="#3-C如何使用cpp文件的函数" class="headerlink" title="3.C如何使用cpp文件的函数?"></a>3.C如何使用cpp文件的函数?</h5><p>用<code>extern &quot;C&quot;</code>。</p><h5 id="4-struct内存问题？"><a href="#4-struct内存问题？" class="headerlink" title="4.struct内存问题？"></a>4.struct内存问题？</h5><p>内存对齐会将依次向结构内变量扩展，最小单位为最长的变量的长度。</p><p>如：</p><pre><code class="c">struct A{    char a;   //char为1字节    long b;   //long为4字节，所以char也扩展为4字节，总长度为8字节    char c;      //long为4字节，所以char也扩展为4字节，总长度为12字节    double d; //double为8字节，所以前者扩展为8*2字节，总长度为24字节};</code></pre><h5 id="5-不同文件中如何引用外部变量？"><a href="#5-不同文件中如何引用外部变量？" class="headerlink" title="5.不同文件中如何引用外部变量？"></a>5.不同文件中如何引用外部变量？</h5><p>全局变量或者<code>extern</code>。</p><h5 id="6-C-中拷贝构造函数形参用值来进行传递有什么影响？"><a href="#6-C-中拷贝构造函数形参用值来进行传递有什么影响？" class="headerlink" title="6.C++中拷贝构造函数形参用值来进行传递有什么影响？"></a>6.C++中拷贝构造函数形参用值来进行传递有什么影响？</h5><p>形如CClass(const CClass c_class)会在传值的过程中调用拷贝构造函数，从而达到死循环。</p><h5 id="7-红黑树较AVL树的优点"><a href="#7-红黑树较AVL树的优点" class="headerlink" title="7.红黑树较AVL树的优点"></a>7.红黑树较AVL树的优点</h5><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p><p>所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p><h5 id="8-用memcmp比较两个struct"><a href="#8-用memcmp比较两个struct" class="headerlink" title="8.用memcmp比较两个struct"></a>8.用memcmp比较两个struct</h5><ol><li>结构体成员都是同样字节长度的数据类型，即长度一致，不会由字节对齐而产生垃圾值；</li><li>如果结构体在赋值前调用memset进行了清零初始化操作，那么字节对齐是填充的内容均是0。</li></ol><h5 id="9、浮点数的比较"><a href="#9、浮点数的比较" class="headerlink" title="9、浮点数的比较"></a>9、浮点数的比较</h5><p>对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值</p><h5 id="10、printf压栈问题"><a href="#10、printf压栈问题" class="headerlink" title="10、printf压栈问题"></a>10、printf压栈问题</h5><p>printf压栈顺序从右到左，入栈计算；然后再从栈顶逐个输出，出栈直接输出。</p><p>i++会拷贝一份副本，++i直接在原数据操作。</p><h5 id="11、IP地址正则表达式的写法"><a href="#11、IP地址正则表达式的写法" class="headerlink" title="11、IP地址正则表达式的写法"></a>11、IP地址正则表达式的写法</h5><p>((25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d))).){3}(25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))</p><h5 id="12、XML"><a href="#12、XML" class="headerlink" title="12、XML"></a>12、XML</h5><p>可扩展标记语言，树结构</p><h5 id="13、什么技术可以代替宏定义"><a href="#13、什么技术可以代替宏定义" class="headerlink" title="13、什么技术可以代替宏定义"></a>13、什么技术可以代替宏定义</h5><p>C++里面可以：const实现常量、inline内联替代宏函数、typedef替代类型定义、条件编译。</p><p>1． C中使用define这种形式宏定义的原因是因为，C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了参数压栈，代码生成等一系列的操作,因此，效率很高，这是它在C中被使用的一个主要原因。</p><p>2． 这种宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p><p>3． 在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现(因为无法将this指针放在合适的位置)。</p><p>4． inline 推出的目的，也正是为了取代这种表达式形式的宏定义，它消除了宏定义的缺点，同时又很好地继承了宏定义的优点。</p><h5 id="14、云盘秒传"><a href="#14、云盘秒传" class="headerlink" title="14、云盘秒传"></a>14、云盘秒传</h5><p>你上传的文件如果是公共文件，也就是云端已经有和你文件指纹(MD5，哈希值等特征码)一样的文件时，上传就是秒传了</p><h5 id="15、动态链接库的接口函数是什么"><a href="#15、动态链接库的接口函数是什么" class="headerlink" title="15、动态链接库的接口函数是什么"></a>15、动态链接库的接口函数是什么</h5><p>将需要预留的接口定义称为全局函数即可(非静态函数)。</p><p>一、动态链接库的接口，其本质即为动态链接库内定义的可供外部调用的函数。<br>二、除static修饰的静态函数外，其它函数均可以被其它文件调用，也就是任何一个非静态函数，都可以称之为动态链接库的接口。<br>三、为了使得使用动态链接库的开发人员了解接口的定义及调用方式，通畅会书写一个或一组头文件(.h)，包含如下内容：<br>1、供外部调用的所有函数的声明。包括函数名，返回值，参数列表。<br>2、如果存在供外部使用的自定义数据结构，如枚举，共用体，结构体等，也需要定义在头文件中。<br>3、推荐在头文件中添加注释，说明每个函数的参数的含义，何种情况下调用，返回值代表什么意义等。</p><h5 id="16、explicit关键字的作用"><a href="#16、explicit关键字的作用" class="headerlink" title="16、explicit关键字的作用"></a>16、explicit关键字的作用</h5><p>这个关键字只能用在类内部的构造函数声明上，而不能用在类外部的函数定义上，它的作用是不能进行隐式转换。</p><h5 id="17、main函数的参数"><a href="#17、main函数的参数" class="headerlink" title="17、main函数的参数"></a>17、main函数的参数</h5><p>规定argc(第一个形参)必须是整型变量,argv( 第二个形参)必须是指向字符串的指针数组。</p><h5 id="18、如果一个单线程阻塞了一个系统调用，比如read-如何解决"><a href="#18、如果一个单线程阻塞了一个系统调用，比如read-如何解决" class="headerlink" title="18、如果一个单线程阻塞了一个系统调用，比如read,如何解决"></a>18、如果一个单线程阻塞了一个系统调用，比如read,如何解决</h5><p>使用select函数进行定时读取，多次阻塞无效后，放弃资源，提示应用系统错误信息，交给用户进一步排查；也可以是将read设置为非阻塞</p><h5 id="19、core-dump-打印堆栈信息"><a href="#19、core-dump-打印堆栈信息" class="headerlink" title="19、core dump 打印堆栈信息"></a>19、core dump 打印堆栈信息</h5><p>backtrack命令查看当前sp指针所在的堆栈帧</p><h5 id="20、系统调用与函数调用"><a href="#20、系统调用与函数调用" class="headerlink" title="20、系统调用与函数调用"></a>20、系统调用与函数调用</h5><p>系统调用<br>1.使用INT和IRET指令，内核和应用程序使用的是不同的堆栈，因此存在堆栈的切换，从用户态切换到内核态，从而可以使用特权指令操控设备<br>2.依赖于内核，不保证移植性<br>3.在用户空间和内核上下文环境间切换，开销较大 </p><p>4.是操作系统的一个入口点<br>函数调用<br>1.使用CALL和RET指令，调用时没有堆栈切换<br>2.平台移植性好<br>3.属于过程调用，调用开销较小<br>4.一个普通功能函数的调用</p><h5 id="21、stdcall和cdecl有什么区别？"><a href="#21、stdcall和cdecl有什么区别？" class="headerlink" title="21、stdcall和cdecl有什么区别？"></a>21、<strong>stdcall和</strong>cdecl有什么区别？</h5><p>对于<strong>stdcall方式被调用者自身在函数返回前清空堆栈；而</strong>cdecl则由调用者维护内存堆栈，所以调用者函数生成的汇编代码比前一种方式长。</p><h5 id="22、connect实现了什么？UDP是否可以使用？"><a href="#22、connect实现了什么？UDP是否可以使用？" class="headerlink" title="22、connect实现了什么？UDP是否可以使用？"></a>22、connect实现了什么？UDP是否可以使用？</h5><p>tcp使用connect函数,经过三次握手建立连接</p><p>UDP可以使用，在UDP收发数据有两种方式：</p><p>socket-&gt;sendto/recvfrom<br>socket-&gt;connect-&gt;send/recv<br>UDP socket使用connect仅仅是指定了唯一的IP地址和端口号，没有三次握手。这样做的目的是限制socket仅能与一个对端交换数据报。</p><h5 id="23、TCP-socket接收数据怎么实现的，recv的返回值"><a href="#23、TCP-socket接收数据怎么实现的，recv的返回值" class="headerlink" title="23、TCP socket接收数据怎么实现的，recv的返回值"></a>23、TCP socket接收数据怎么实现的，recv的返回值</h5><p>使用read或recv</p><p>返回值有：</p><ul><li>&gt;0 成功接收的数据大小</li><li>=0 对方连接关闭</li><li>-1 错误，需要获取错误码errno</li></ul><h5 id="24、epoll的水平触发和边缘触发"><a href="#24、epoll的水平触发和边缘触发" class="headerlink" title="24、epoll的水平触发和边缘触发"></a>24、epoll的水平触发和边缘触发</h5><p>epoll是实现I/O多路复用的一种方法,有水平触发（level trigger，LT，默认)和边缘触发（edge trigger，ET）两种工作模式，区别在于两种模式的返回就绪状态的时间不同。</p><p>epoll将用户关心的文件描述符放到内核里的一个事件表中，而不是像select/poll每次调用都需要重复传入文件描述符集或事件集。</p><hr><h4 id="数据结构与算法："><a href="#数据结构与算法：" class="headerlink" title="数据结构与算法："></a><em>数据结构与算法：</em></h4><h5 id="1-中国象棋跳马问题"><a href="#1-中国象棋跳马问题" class="headerlink" title="1.中国象棋跳马问题"></a>1.中国象棋跳马问题</h5><p>如果只需要知道最短步数：广度优先遍历。</p><p>如果需要知道最短步数与相应步骤：广度优先遍历后接深度优先遍历。</p><h5 id="2-青蛙跳台阶的问题"><a href="#2-青蛙跳台阶的问题" class="headerlink" title="2.青蛙跳台阶的问题"></a>2.青蛙跳台阶的问题</h5><p>递归或动态规划。</p><h5 id="3-N个点的网络，求任意两点的最短路径"><a href="#3-N个点的网络，求任意两点的最短路径" class="headerlink" title="3.N个点的网络，求任意两点的最短路径"></a>3.N个点的网络，求任意两点的最短路径</h5><p>如果查询次数很少则用单源最短路Dijkstra（每次选择离集合最近的一个点加入集合）,查询次数很多则用Floyd（依次选择结点为中间结点，比较原长度和通过中间结点后的长度）。</p><h5 id="4-4亿个数，你只有1G内存，你怎么判断某个数已经出现？"><a href="#4-4亿个数，你只有1G内存，你怎么判断某个数已经出现？" class="headerlink" title="4.4亿个数，你只有1G内存，你怎么判断某个数已经出现？"></a>4.4亿个数，你只有1G内存，你怎么判断某个数已经出现？</h5><p>1G内存即为2^30B=2^33bits，那么由于int型一共为2^32个左右，那么通过2进制表示每个数，若概述出现，则对应该位置一。</p><h5 id="5-两个水晶球确定楼层问题"><a href="#5-两个水晶球确定楼层问题" class="headerlink" title="5.两个水晶球确定楼层问题"></a>5.两个水晶球确定楼层问题</h5><p>通过x+(x-1)+(x-2)…+1来确定x的值。</p><hr><h4 id="面试中："><a href="#面试中：" class="headerlink" title="面试中："></a>面试中：</h4><h4 id="一面："><a href="#一面：" class="headerlink" title="一面："></a>一面：</h4><h5 id="1、内存对齐问题"><a href="#1、内存对齐问题" class="headerlink" title="1、内存对齐问题"></a>1、内存对齐问题</h5><p>见上</p><h5 id="2、函数指针和指针函数"><a href="#2、函数指针和指针函数" class="headerlink" title="2、函数指针和指针函数"></a>2、函数指针和指针函数</h5><p>函数在内存中是存放在栈中的，函数指针本质是指针，是指向在内存中存放的函数的地址的指针。而指针函数本质是函数，是指以指针形式为返回值的函数，常见的有二叉树。</p><h5 id="3、网络中的time-wait"><a href="#3、网络中的time-wait" class="headerlink" title="3、网络中的time_wait"></a>3、网络中的time_wait</h5><p>一个数据报在发送途中或者响应过程中有可能成为残余的数据报，因此必须等待足够长的时间避免新的连接会收到先前连接的残余数据报，而造成状态错误。</p><p>确保被动关闭方已正常关闭。</p><h5 id="4、整型溢出问题"><a href="#4、整型溢出问题" class="headerlink" title="4、整型溢出问题"></a>4、整型溢出问题</h5><p>在二分查找中，mid应该等于i+(j-i)/2，防止整型溢出。</p><h5 id="5、struct-和union区别"><a href="#5、struct-和union区别" class="headerlink" title="5、struct 和union区别"></a>5、struct 和union区别</h5><p>union是各个变量共享一片存储区，以最长的变量长度为空间长度。</p><p>1.在存储多个成员信息时，编译器会自动给struct第个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。</p><p>2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。</p><p>3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。</p><h5 id="6、计算1-n之和，不用赋值句"><a href="#6、计算1-n之和，不用赋值句" class="headerlink" title="6、计算1-n之和，不用赋值句"></a>6、计算1-n之和，不用赋值句</h5><p>用递归进行解答。</p><h5 id="7、函数的重载和覆盖问题"><a href="#7、函数的重载和覆盖问题" class="headerlink" title="7、函数的重载和覆盖问题"></a>7、函数的重载和覆盖问题</h5><p>重载时，不能是只有返回值不同的函数。</p><h5 id="8、引用和指针的区别"><a href="#8、引用和指针的区别" class="headerlink" title="8、引用和指针的区别"></a>8、引用和指针的区别</h5><ol><li>指针是一个实体，而引用仅是个别名；</li><li>引用使用时无需解引用（*），指针需要解引用；</li><li>引用只能在定义时被初始化一次，之后不可变；指针可变；<br>引用“从一而终” </li><li>引用没有 const，指针有 const，const 的指针不可变；</li><li>引用不能为空，指针可以为空；</li><li>“sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身（所指向的变量或对象的地址）的大小；<br>typeid（T） == typeid（T&amp;） 恒为真，sizeof（T） == sizeof（T&amp;） 恒为真，但是当引用作为类成员名称时，其占用空间与指针相同4个字节（没找到标准的规定）。</li><li>指针和引用的自增（++）运算意义不一样；</li></ol><h4 id="二面："><a href="#二面：" class="headerlink" title="二面："></a>二面：</h4><h5 id="1、I-O多路复用"><a href="#1、I-O多路复用" class="headerlink" title="1、I/O多路复用"></a>1、I/O多路复用</h5><h5 id="2、memcpy写一下代码"><a href="#2、memcpy写一下代码" class="headerlink" title="2、memcpy写一下代码"></a>2、memcpy写一下代码</h5><h5 id="3、哈希表和树的区别"><a href="#3、哈希表和树的区别" class="headerlink" title="3、哈希表和树的区别"></a>3、哈希表和树的区别</h5><h5 id="4、宏定义"><a href="#4、宏定义" class="headerlink" title="4、宏定义"></a>4、宏定义</h5><h5 id="5、败者树和归并排序"><a href="#5、败者树和归并排序" class="headerlink" title="5、败者树和归并排序"></a>5、败者树和归并排序</h5><h5 id="6、数据库的底层机制"><a href="#6、数据库的底层机制" class="headerlink" title="6、数据库的底层机制"></a>6、数据库的底层机制</h5><h5 id="7、linux的代码调试"><a href="#7、linux的代码调试" class="headerlink" title="7、linux的代码调试"></a>7、linux的代码调试</h5><h5 id="8、进程与线程的区别"><a href="#8、进程与线程的区别" class="headerlink" title="8、进程与线程的区别"></a>8、进程与线程的区别</h5><h5 id="9、写一个函数指针"><a href="#9、写一个函数指针" class="headerlink" title="9、写一个函数指针"></a>9、写一个函数指针</h5><p>gg，很多没答清楚，很多是知道概念，问细了就不会。</p>]]></content>
    
    
    
    <tags>
      
      <tag>招聘经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大话设计模式学习笔记</title>
    <link href="/2020/03/25/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/25/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="学习书目《大话设计模式》，程杰著"><a href="#学习书目《大话设计模式》，程杰著" class="headerlink" title="学习书目《大话设计模式》，程杰著"></a>学习书目《大话设计模式》，程杰著</h2><h4 id="Date-2020-3-25"><a href="#Date-2020-3-25" class="headerlink" title="Date:2020-3-25"></a><em>Date:2020-3-25</em></h4><h4 id="草堂春睡足，窗外日迟迟"><a href="#草堂春睡足，窗外日迟迟" class="headerlink" title="草堂春睡足，窗外日迟迟"></a><center><em>草堂春睡足，窗外日迟迟</em></center></h4><p>根据b站up主codesheep的建议，我近期买了《大话设计模式》一书，今天到货，富有色彩和卡通性的外皮，我就知道，这一定是一本读起来很轻松的书。</p><p>想想看，好像已经很久没有这样读书了。大学懒了四年，当年那个抱着《明朝那些事儿》，抱着《辞海》都能翻烂的自己哪里去了？喜欢这个信息化高速发展的世界，但它的很多弊端也深深影响了我们自己，浮躁，追求即时性的交互和快感，这不，完成这篇学习笔记中间，我又躺床上看了半个小时直播。痛定思痛，从这本书开始，我要努力找回当初的那个自己，学下去，沉下去。</p><p>说到这本书，仅仅阅读了一个半小时的时间，我就有了很多收获。内容上以小菜和老鸟（当然，因为很多基础不牢靠。我不得不中间跳转至附录先对基本知识打个底）的日常生活对话引出。就第一篇从面向过程的编程思想向面向对象的编程思想的转变，就足够的浅显易懂。<strong>面向对象</strong>我知道了很久，但一直用不起来，虽然其四大特点：</p><ol><li>可维护性</li><li>可复用性</li><li>可扩展性</li><li>灵活性好</li></ol><p>众所周知，但是却一直无法用在实处，用编程语言的话说，就是不能<strong>实例化</strong>，真正地做到对这个概念“初始化”。通过本文中老鸟对于小菜关于计算器的设计思想的几个建议，我确实体会到了面向对象编程的魅力。</p><p>面向对象，就是要通过封装、继承、多态的方式，降低程序的耦合性，就是以一种最低的代价将来可以对程序进行修改和补充。这个过程中，我觉得最重要的就是抓住程序中具体功能的普遍性，将其拿出来，独立成块。</p><p>怎么抓呢？譬如计算器的设计，其核心就是计算和显示两个部分。如果用过程化的思想来设计，就是输入什么，做什么，得到什么。而对象化的思想是什么呢？计算是一块，显示是一块。对于计算，我们将所有的计算方式放在一个类中，就像活字印刷术，哪里错了改哪里。建一个小房子，让+、-、<em>、/，住进去，需要怎么算，就让运算的数字去敲门，找到对应的运算符号，这就是*</em>封装**。</p><p>惭愧惭愧，读到1.9的章节时，基础薄弱的毛病暴露出来了，只能听从作者的建议先去附录处把基础打牢实，以下内容为附录A.1-A.5的内容理解。</p><p>不抄概念，用自己的话说，我们将这个世界的凡此种种都当做一个<strong>对象</strong>，有共同特点的对象，就是一个<strong>类</strong>，比如哺乳动物、爬行动物。我们划好类，再通过<strong>实例化</strong>来生成一个对象，生成一个对象的方式有很多种，比如卵生、胎生，这就是不同的<strong>构造函数</strong>以及他们之间的<strong>重载</strong>关系。</p><p>什么是属性，什么是字段呢？通常来说，<strong>属性</strong>位于public中，是任何其他类都可以访问的，也就是一个方法，一个函数。而<strong>字段</strong>呢，就是变量，就是private中，本类成员所独有的。哪怕是本类的子类都不可以访问他们，这样就能做到保护一个类的隐私权。那么本类对象该如何访问呢，就是get和set，get用于读取私有变量，set用于设置私有变量。</p><p>ps：代码规范化新知识：</p><ul><li><code>string A;</code>这样的命名方式是不规范的，我们不清楚A到底是什么，而我以前却习惯随手这样命名，当时是简单了，偷懒了，以后翻起来想看，真是云里雾里，参考形式<code>string strNumberA</code>。</li><li>在写判断语句的时候，能不要重复判断就不要重复判断，多支路的时候多用switch函数。</li><li>边界条件能考虑就要考虑，还有非法输入，要扼杀在摇篮里，提高程序的鲁棒性。</li><li>类名首字母大写，多单词各个首字母大写，方便见文知意。</li><li>属性（函数体）以大写字母开头，字段（变量）以小写字母或者下划线开头。</li></ul><p>今日事今日毕，2020-3-25记。</p><hr><h4 id="Date-2020-3-26"><a href="#Date-2020-3-26" class="headerlink" title="Date:2020-3-26"></a><em>Date:2020-3-26</em></h4><h4 id="问渠哪得清如水，为有源头活水来"><a href="#问渠哪得清如水，为有源头活水来" class="headerlink" title="问渠哪得清如水，为有源头活水来"></a><center><em>问渠哪得清如水，为有源头活水来</em></center></h4><p>接着昨天的学习，昨天学习了面向对象语言中子类与父类之间的区别，那么两者之间的关系是如何传递的呢，是<strong>继承</strong>，就是将子类的公共部分尽可能的放在父类中。两者的关系应该是“is-a”，而不是“has-a”，这点也说明依靠继承作为枢纽不是越多越好。</p><p>同一父类下的各个子类想要执行相同的动作，就需要用到他们自己的代码来实现，这也就是<strong>多态</strong>，书中举到的京剧的例子特别好，儿子为了接替父亲的工作，还同时要保有自己的特色，这就是多态。想要完全接替父类实现，需要依靠virtual关键字和override，前者在父类中将方法抽象化，后者则在子类中实现方法覆写。</p><p>抽象类的定义很简单，实例化没有任何意义，对应的关键字abstract，同时没有方法体，这与树结构中的枝干不谋而合，而叶子正是可实例化的具体类。</p><p>为了使彼此不同的类之间在某些功能相同的代码上可以复用，就引申出接口interface的概念。接口有很多要求，最重要的一点是命名需要前面加大写”I“，类名与接口用“，”分隔。据此，我们认清楚了在面向对象编程中，是通过重构得到了抽象类，而接口却是往往在类生成之前就已经提出。</p><p>最后是关于委托的概念，delegate委托对象，event事件对象，简单的来说，就是形成一个委托函数，当作为自变量的类引出某种操作后，书中为猫叫，那么作为因变量的类也就是在委托中的事件对象就要收到信息，书中为老鼠跑。换言之，event是一个由delegate组成的容器，当事件发生了，就把受到影响的delegate加入其中（个人理解）。</p><p>以上就是关于附录A的全部学习内容，明天继续正片内容，2020-3-26记。</p><hr><h4 id="Date-2020-3-27"><a href="#Date-2020-3-27" class="headerlink" title="Date:2020-3-27"></a><em>Date:2020-3-27</em></h4><h4 id="临阵磨枪，不快也光"><a href="#临阵磨枪，不快也光" class="headerlink" title="临阵磨枪，不快也光"></a><center><em>临阵磨枪，不快也光</em></center></h4><p>今天学习了两种基本的设计模式，<strong>简单工厂模式</strong>和<strong>策略模式</strong>。开始看得有点云里雾里，没能看出两者之间显著的区别和优劣势。题目涉及建立一个商场买卖交易系统，这个系统在计算出用户购买的物品价格的同时，还需要对于不同的优惠方案（满减与打折）能够提供不同的解决方案。</p><p>由于不同的物品之间可能享有不同的优惠活动，我的第一个想法就是将计算每件物品的总价后，转入一个计算优惠的类中，该类将派生出原价类，满减类和打折类。通过读入不同的选择，对商品转入不同的类进行计算。在简单工厂模式中，客户端程序通过<code>CashFactory</code>确定不同的优惠活动，可以生成不同的<code>CashSuper</code>对象，由于<code>CashSuper</code>为抽象类，那么就可以依靠多态的特性来确定最后的价格。之后大鸟提出，商家会经常性地改变定价策略，那么维护起来这段代码就会变得比较繁琐，既要在客户端程序中修改选择框的内容，也要在<code>CashFactory</code>中添加相应的条件。换言之，客户端需要既知道<code>CashFactory</code>，也知道<code>CashSuper</code>。</p><p>而策略模式所追求的，就是将仅有算法所影响的部分放在一起，将算法封装起来，需要的时候进行调用。这样做的好处就是，客户端可以不知道算法细节，也就是说将在客户端放置的switch函数可以移出，减少了客户端每次进行判断所花费的时长。</p><p>但到这里，我依旧没有很好地将两种设计模式相区分，总结一下，简单工厂模式中需要设计五个类以及一个客户端。其中由一个抽象类作为三种优惠模式的基类，同时还有三种优惠模式各自对应的派生类，以及一个名为现金收费工厂类。现金收费工程类中，依据在客户端中选择的不同优惠条件返回不同的对象。</p><p>在策略模式中同样有五个类，其中基类与三个派生类不变，唯一区别的在于<code>CashFactory</code>与<code>CashContext</code>。我发现两者的区别在于判断的位置发生了变换。<code>CashFactory</code>中进行了判断，而<code>CashContext</code>将判断放在了基类产生派生类的过程中。可能如此这般，就实现了算法的整合封装。</p><p>明天要参加深信服的电话面试，今天就先到这里为止，策略模式的结尾文中提到了改善switch函数的方法即反射技术，后续再深入研究，2020-3-27记。</p><hr><h4 id="Date-2020-3-29"><a href="#Date-2020-3-29" class="headerlink" title="Date:2020-3-29"></a><em>Date:2020-3-29</em></h4><h4 id="人有悲欢离合，月有阴晴圆缺"><a href="#人有悲欢离合，月有阴晴圆缺" class="headerlink" title="人有悲欢离合，月有阴晴圆缺"></a><center>人有悲欢离合，月有阴晴圆缺</center></h4><p>今天的深信服面试挂掉了，还是自己太菜了，面试官问的很多问题无法给出清晰的回答，好好努力提高自己吧。明天继续学习设计模式。</p><hr><h4 id="Date-2020-3-31"><a href="#Date-2020-3-31" class="headerlink" title="Date:2020-3-31"></a><em>Date:2020-3-31</em></h4><h4 id="学而时习之，不亦说乎"><a href="#学而时习之，不亦说乎" class="headerlink" title="学而时习之，不亦说乎"></a><center>学而时习之，不亦说乎</center></h4><p>这两天由于面试的关系，落下了设计模式的学习，要抓紧补上来。</p><p>本书在第三四章讲的内容主要还是与耦合有关，单一职责原则就是将类细分到只有一个引起它变化的原因。这个原则的核心就是发现类的职责并将这些职责分离开来。如果我们有多于一个动机去改变一个类，就会不满足单一职责原则。</p><p>第四章的内容我还真是感同身受，两次考研失败，真的到了一个对于人生很迷茫的时期，小菜的境遇，那首“海阔天空”都唱到了我的心里。是啊，二战考研前思考问题还是太过于狭隘了，当我把全部家当梭哈在了考研上，考研的结果就会对我无比重要，我甚至不能允许发生任何意外。背水一战是韩信的专利，人生不是赌博，也不应该将未来的道路限死，至少这点对我适用。<strong>开放-封闭原则</strong>我深有体会，软件实体应该可以扩展，但不应该修改。程序的变化和人生的变化是一样的，你不知道什么时候就会突然到你面前，但我们面对变化的时候，要做的就是创建抽象，来隔离以后还可能发生的同类型的变化。考研失败就是我的人生变化，上次失败的教训告诉我鸡蛋是不能放在一个篮子中的。当前这个年龄，读书和步入社会，我要两把抓。</p><p>羡慕小菜的桃花运，还没有女生找过我修电脑。确实，修电脑有时候比修收音机简单。<strong>依赖倒转原则</strong>看似很抽象，核心就是要面向接口编程，无论是高层模块，还是低层模块，都应该依赖抽象，即具体功能，无论我使用谁家的主板，该有的功能都能实现。</p><p>这些东西都是在讲面向对象编程的思想，一种人对于万事万物的归类的思想。总是把相同的地方归出来，把不同的地方拿出来，我们说可以飞的是鸟，那么企鹅在计算机的理解里面就不应该是鸟。除非划分出可飞的鸟和不可飞的鸟。<strong>里氏代换原则</strong>即如此，子类型必须能够替换它们的父类型。比如c语言是特别考虑内存分配的语言，如果在高层模块中仍然需要考虑这些内存分配的细节，那么就不是一个好的高层模块，。</p><p><strong>装饰模式</strong>属于书中新提出的一个设计模式，以小菜的穿衣打扮作为引子，引出了一系列关于如何对对象动态地添加一些额外的职能。这种装饰的过程应该比生成一个新的子类更加灵活。用白话将，就是我不应该生成一个穿着白大褂、皮鞋的小菜对象，而是应该生成一个小菜对象，给他穿上白大褂和皮鞋。<strong>Decorate</strong>就是在上一步的基础上进行再加工的过程。为什么要进行再加工，就是由于发生了某种特定情况，只有需要进行再加工的时候，才进行下一步的处理，这个过程就是装饰模式。</p><p>对本书的学习有点感觉了，虽然之前所学的，简单工厂模式，策略模式，还是今天的装饰模式，我都还不能熟练应用，甚至彼此之间还有些混淆，希望接下来的学习可以更清楚地看清这些设计模式，20-3-31记。</p><hr><h4 id="Date-2020-4-2"><a href="#Date-2020-4-2" class="headerlink" title="Date:2020-4-2"></a><em>Date:2020-4-2</em></h4><h4 id="山重水复疑无路，柳暗花明又一村"><a href="#山重水复疑无路，柳暗花明又一村" class="headerlink" title="山重水复疑无路，柳暗花明又一村"></a><center>山重水复疑无路，柳暗花明又一村</center></h4><p>继续设计模式的学习，书中通过校园恋爱的故事引出了<strong>代理模式</strong>，代理模式理解起来很简单，就是找一个中间商，就是在<code>Subject</code>类与<code>RealSubject</code>类中间通过<code>Proxy</code>类进行保存一个引用使得代理可以访问实体，这样对象就可以在不知道实体是谁的前提下调用实体的函数。代理模式分类挺复杂的，有远程代理，虚拟代理，安全代理和智能指引。没有接触实际案例很难理解这个分类名，也就虚拟代理常用于网页中的图片生成还算理解。</p><p>接下来，就是讲到<strong>工厂方法模式</strong>和简单工厂模式的区别，个人理解上，核心点还是因为简单工厂模式违反了开放-封闭原则，新的功能的实现，只需要写新的工厂类的代码就好了。但是，工厂方法模式也将判断到底选择哪个工厂的问题从工厂内部逻辑判断移动到了客户端中实现，也就是客户需要先进行判断。其实这里我觉得更多地，工厂方法模式就是追求代码的封闭性，追求一旦写成尽量不修改只添加的原则。</p><p>第九章的部分探讨了计算机一个很深入的内容，深拷贝和浅拷贝。深拷贝如<code>copy</code>，是完全生成一个新的对象，使其与原有的对象各变量数据完全一致，而浅拷贝就是<code>clone</code>，在简单的变量面前是进行了复制，但是在复制引用的对象时，复制的是一个新的引用名，来指向最开始的变量。深拷贝和浅拷贝的区别，在<strong>原型模式</strong>中影响很大，一定要明确自己想要克隆的对象想要实现的是变量本身的复制还是变量的引用的复制。</p><p><strong>模板方法模式</strong>也是最常用的设计模式之一了，通过将父类中的一些抽象放到子类中去实现。所以在父类中定义的是算法的骨架，而一些步骤被延迟到了子类中去实现。这其中运用到了将子类变量的声明改成了父类（在客户端中），利用了多态性实现了代码的复用。这个设计模式很好理解，可以尽可能地去除子类中的重复代码而单独提出不一样的地方。</p><p>今天先这样吧，碧蓝航线可能会给我offer，希望可以开启我的游戏制作生涯。明天开始加倍努力，全国哀悼日，不碰娱乐项目。20-4-2记。</p><hr><h4 id="Date-2020-4-2-1"><a href="#Date-2020-4-2-1" class="headerlink" title="Date:2020-4-2"></a><em>Date:2020-4-2</em></h4><h4 id="三杯两盏淡酒，怎敌他晚来风急"><a href="#三杯两盏淡酒，怎敌他晚来风急" class="headerlink" title="三杯两盏淡酒，怎敌他晚来风急"></a><center>三杯两盏淡酒，怎敌他晚来风急</center></h4><p>开门见山地学了一个设计原则，<strong>迪米特法则</strong>。例子很切身实际，部门员工的相互推诿，办事效率低，其关键就是在于类之间存在紧耦合。为什么会存在紧耦合呢，其实这里的IT部门由于没有相应的部门主管，部门的员工都是各自忙自己的，这样就导致彼此之间各是一个类。当有了部门主管，我们只需要整合部门内的全部员工成为一个类，有任务就委托给部门主管，由部门主管安排内部员工干活。</p><p>对于很多很多彼此相关或者无关的类，其实我们需要将他们分门别类，彼此划分开，这就用到了<strong>外观模式</strong>，书中通过买卖股票，买卖基金的例子来形象地描述了外观模式的作用。为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这一接口使得这一子系统更加容易使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA从零单排——难题错题篇</title>
    <link href="/2020/03/25/JAVA%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/"/>
    <url>/2020/03/25/JAVA%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA从零单排——语言学习篇</title>
    <link href="/2020/03/25/JAVA%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <url>/2020/03/25/JAVA%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="初时JAVA"><a href="#初时JAVA" class="headerlink" title="初时JAVA"></a>初时JAVA</h2><p>人生就像下一块巧克力，你不打开永远不会知道它是什么口味的。</p><p>大学接触的第一门编程语言是C语言，作为小白来说，很多东西看不懂，搞不清，勉勉强强能使用C的一些基本功能。后来</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程语言学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++从零单排——语言学习篇</title>
    <link href="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <url>/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++从零单排——难题错题篇</title>
    <link href="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/"/>
    <url>/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h4 id="以下题目均来自于牛客网https-www-nowcoder-com-intelligentTest"><a href="#以下题目均来自于牛客网https-www-nowcoder-com-intelligentTest" class="headerlink" title="以下题目均来自于牛客网https://www.nowcoder.com/intelligentTest"></a>以下题目均来自于牛客网<a href="https://www.nowcoder.com/intelligentTest" target="_blank" rel="noopener">https://www.nowcoder.com/intelligentTest</a></h4><h4 id="我们的口号是："><a href="#我们的口号是：" class="headerlink" title="我们的口号是："></a><em>我们的口号是：</em></h4><h1 id="每天十道，提神醒脑！"><a href="#每天十道，提神醒脑！" class="headerlink" title="每天十道，提神醒脑！"></a><font face="华文行楷">每天十道，提神醒脑！</font></h1><h4 id="Date-2020-3-25"><a href="#Date-2020-3-25" class="headerlink" title="Date:2020-3-25"></a><em>Date:2020-3-25</em></h4><h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-25-1.png" srcset="/img/loading.gif" alt></p><p>考察点：数组名作为指针的时候是一个常量，而指针是一个变量。</p><h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-25-2.png" srcset="/img/loading.gif" alt></p><p>不管基类析构函数加不加virtual，只要是声明的是基类的指针，即使实际指向的实例是派生类的，也不会调用派生类的析构方法。</p><p>不管基类析构函数加不加virtual，只要是声明的是派生类的指针，并且实际指向的实例是派生类的，会先调用派生类的析构方法，然后级联调用父类的析构方法。参见：</p><pre><code class="c++">#include&lt;stdio.h&gt;class A{    public:    A(){ printf(&quot;A&quot;);}    ~A(){ printf(&quot;~A&quot;);}};class B: public A{    public:        B(){ printf(&quot;B&quot;);}        ~B(){ printf(&quot;~B&quot;);}};    int main(){    B* c = new B[2];    delete[] c;    return 0;}</code></pre><p>输出<strong>ABAB<del>B</del>A<del>B</del>A</strong></p><hr><h4 id="Date-2020-3-28"><a href="#Date-2020-3-28" class="headerlink" title="Date:2020-3-28"></a><em>Date:2020-3-28</em></h4><h4 id="1、-1"><a href="#1、-1" class="headerlink" title="1、"></a>1、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-28-1.png" srcset="/img/loading.gif" alt></p><p>正确写法：<code>b[5]=*(b+5)</code>。</p><h4 id="2、-1"><a href="#2、-1" class="headerlink" title="2、"></a>2、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-28-2.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-28-2%E7%AD%94.png" srcset="/img/loading.gif" alt></p><h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-28-3.png" srcset="/img/loading.gif" alt></p><p>【解释】格式字符必须小写，题中的”%8U”不会当作格式控制符，而是原样输出，变</p><p>量a将没有对应的格式说明，也不会输出。所以正确答案为B（注意：在VC下结果为U）。</p><h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-28-4.png" srcset="/img/loading.gif" alt></p><p>A正确。</p><p>B二维数组最后一维必须有值。***数组只能省略第一维（感谢评论提醒）</p><p>CD都超出长度，最后有”\0”</p><h4 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-28-5.png" srcset="/img/loading.gif" alt></p><p>忽略了第一次i++将先执行，所以不包含“11”。</p><h4 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-28-6.png" srcset="/img/loading.gif" alt></p><p>先分析一下函数的复杂度： </p><p>f(n) = f(n-1)+f(n-2)+….+f(2)+f(1) +f(0)<br>   = 2( f(n-2)+ f(n-3)+….+f(2)+f(1) +f(0))</p><p>   =4( f(n-3) +f(n-4)+….+f(2)+f(1) +f(0))<br>   …<br>   = 2^(n-1)*f(0)</p><p>复杂度为O(2^(n-1))<br>n = 35时,计算量为2^34<br>主流PC机的每秒钟计算量约为10^7~10^8次</p><p>因此计算时间大约在几分钟</p><hr><h4 id="Date-2020-3-30"><a href="#Date-2020-3-30" class="headerlink" title="Date:2020-3-30"></a><em>Date:2020-3-30</em></h4><h4 id="1、-2"><a href="#1、-2" class="headerlink" title="1、"></a>1、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-30-1.png" srcset="/img/loading.gif" alt></p><p>先来计算Z的值，Z将替换成Y<em>X/2，再把X+1替换Y，得Z=X+1</em></p><p>X/2，再用5替换X，得Z=5+1*5/2，所以Z的值是7（注意整除）。a=Y宏替换后</p><p>变成a=X+1，再将5替换X，得a=5+1，即a的值是6，但输出是–a，a先减1即</p><p>变为5，再输出。故正确答案是D。</p><h4 id="2、-2"><a href="#2、-2" class="headerlink" title="2、"></a>2、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-30-2.png" srcset="/img/loading.gif" alt></p><p>结构体变量不管其包含有多少个成员，都应当看成是一个整体。在程序运行</p><p>期间，只要在变量的生存期内，所有成员一直驻留在内存中，不可能出现有的成员驻留内</p><p>存，有的成员不驻留内存的情况。故选择答案是A。</p><h4 id="3、-1"><a href="#3、-1" class="headerlink" title="3、"></a>3、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-30-3.png" srcset="/img/loading.gif" alt></p><p>函数重载（overload）<br>函数重载是指在一个类中声明多个名称相同但参数列表不同的函数，这些的参数可能个数或顺序，类型不同，但是不能靠返回类型来判断。特征是：<br>（1）相同的范围（在同一个作用域中）；<br>（2）函数名字相同；<br>（3）参数不同；<br>（4）virtual 关键字可有可无（注：函数重载与有无virtual修饰无关）；<br>（5）返回值可以不同；</p><p>函数重写（也称为覆盖 override）<br>函数重写是指子类重新定义基类的虚函数。特征是：<br>（1）不在同一个作用域（分别位于派生类与基类）；<br>（2）函数名字相同；<br>（3）参数相同；<br>（4）基类函数必须有 virtual 关键字，不能有 static 。<br>（5）返回值相同，否则报错；<br>（6）重写函数的访问修饰符可以不同；</p><p>重定义（也称隐藏）<br>（1）不在同一个作用域（分别位于派生类与基类） ；<br>（2）函数名字相同；<br>（3）返回值可以不同；<br>（4）参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆）；<br>（5）参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）；</p><h4 id="4、-1"><a href="#4、-1" class="headerlink" title="4、"></a>4、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-30-4.png" srcset="/img/loading.gif" alt></p><p>p 是 int 的指针类型，scanf 要求 %d 相应参数也是 int 的指针类型，A即可。</p><p>B 项， &amp;p 又取了一次 p 的地址，相当于指针的指针， scanf 尝试写入原本是指针的地址，导致 p 的值被改变（本应写入 p 指向的内存），后续解引用 *p 可能导致访问非法内存 产生运行时读内存错误。</p><p>C 项， *p 解引用取值，是一个未初始化的乱值， scanf 会把该值当作地址，可能导致运行时写内存错误或写入不被期望的内存区域。</p><p>D 项， p 只是一次指针， **p 会编译错误。</p><h4 id="5、-1"><a href="#5、-1" class="headerlink" title="5、"></a>5、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-30-5.png" srcset="/img/loading.gif" alt></p><p>A选项，C++中可以通过对象名和成员运算符访问对象中的成员</p><p>B选项，通过对象的引用变量来访问对象中的成员，如果为一个对象定义了一个引用变量，它们是共占同一段存储单元的，实际上它们是同一个对象，只是用不同的名字表示而已。因此完全可以通过引用变量来访问对象中的成员。</p><p>C选项，类的成员为公有的，即可以被该类的所有成员所访问</p><p>D选项，如果类A把类B声明为自己的友元类，那么在类B中的所有函数中都可以访问类A的私用和保护成员。</p><h4 id="6、-1"><a href="#6、-1" class="headerlink" title="6、"></a>6、</h4><p><img src="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/20-3-30-6.png" srcset="/img/loading.gif" alt></p><p>B项，<br><code>HANDLE hThread = GetCurrentThread();</code><br>获取当前线程的一个伪句柄。该句柄可以复制，但不可继承。不能调用CloseHandle函数来关闭这个句柄。<br>C项<br><code>int sock_fd=socket( int af, int type, int protocol);</code><br>如果调用成功就返回新创建的套接字的描述符，如果失败就返回INVALID_SOCKET（Linux下失败返回-1）</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程语言学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>皮卡丘422的第一篇个人博客</title>
    <link href="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="皮卡丘422的第一篇个人博客"><a href="#皮卡丘422的第一篇个人博客" class="headerlink" title="皮卡丘422的第一篇个人博客"></a><font face="楷体"><center>皮卡丘422的第一篇个人博客</center></font></h1><h4 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h4><p>如果有人跟十年前的我说，二十多岁是人生最难的十年，我肯定不屑一顾。小时候的自己就觉得成年人有多么多么好，多么多么自由。可就是太自由了，人生才容易失去方向。学生思维的三大局限，或者说是人性的弱点——<strong><em>终点型思维，秘籍型思维和空杯型思维</em></strong>，（理论参考知乎用户柴桑）而现在的我，对<strong>终点型思维</strong>有了更深刻的理解。</p><p>第二次与北大失之交臂，可笑的单科线，成了压死骆驼的最后一根稻草。被迫开始考虑找工作，开始研究技术，开始不断充电学习。蓦然回首，我突然发现自己竟然早已陷入了这样的思维之中很深很深。为什么要考北大呢？一半的名校梦，一半的“北大研究生出来就能怎样怎样”。<strong>若不是迫不得已转向的招聘一事给了我当头一棒，我不知还要沉浸在这种思想中多久</strong>。诚然，一所名校的高学历不仅代表着高智商，也往往代表着高能力。不可否认的是，从名校毕业的学生也往往是同龄人里最优秀的，但这份优秀不是源自于名校身份赋予了他多少，而是在于他在名校的环境中学到了多少。这里提名我的大学寝室长，目前就读于哈尔滨工业大学深圳研究院的cs专硕。从毕业后这一年中间歇性的交流之中，我有理由相信，也是毫不夸张的说，他在哈工的这一年，比他在电子科大的四年，包括大四上的考研，所付出的全部还要多很多。他日常会在寝室群里说，同门了，同学了都太厉害了，自己差的很远，得追。至于后面哪怕是疫情阶段，无法返校，他在家的学习生活都是7-12-7。我不知道他都具体学到了什么，但有一点我可以确信，就是他知道了人生要努力，并在努力的路上不断地前行着。</p><p>或许现在意识到这点还不晚。虽然从古至今有太多的文学作品劝人努力，催人奋进，但真的只有一个人切身走到那一步了，无路可退了，才能真的意识到<strong>努力的重要性</strong>。我从小就是一个靠着天赋和老师推着走的学生。娱乐的手段千千万，而学习之路就是完任务。当然，这也局限于家庭、环境所给我带来的学习局限性，我不知道什么是编程，什么是算法，除了语数外政史地生，还有什么东西是一个人的成长应该要学的。老师会跟你说，坚持到大学就解放了；父母会跟你说，学习这条路就是把学校的东西学好。所以我的大学生活，和很多人一样，没有挂科，也没啥荣誉，唯一奋斗过的一段时光，就是大二组队争取了一个大学生建模的省一。作为一个cs科班出身的学生，在大学毕业码过的代码也不过千余行，想想也是可笑。至于走到如今这个时间点，点开许多同龄人的博客、简历，才知道自己四年时间被拉开了多少个身位。</p><p>努力不是头悬梁，锥刺股那么夸张，而是在一个<strong>该学习的时间段去学习，该奋斗的时间段去奋斗</strong>，这点，是我这两年考研经历所教会我的全部。人生也不是向着终点前进，而是一场起点不一样的长跑，跑得远的不代表了胜利，跑得久的才是。<em>这里多嘴一句，教育是个奢侈品，对于任何家庭都是。它贵在的，不仅是昂贵的学区房、一线城市户口、优质的教育资源，更是家长能带给子女的眼界，能否做到以身作则的表率。如果家长嘴里只有：把学校的东西学会了，就够了；小孩子没有隐私权，我说让你干什么，你就干什么；什么是编程，什么是宇宙，什么是量子力学，我不懂，你自己看去；看电视剧是大人的权力，我们才能看，你去学习去，我们老了，学不动了；养儿防老，不孝有三，无后为大等等。那么我请您再好好思考一下，您真的要生这个孩子吗？如果要生，那么在孩子的成长过程中，当你提到别人家的小孩如此怎样的时候，当你望子成龙，望女成凤的时候，请你闭嘴，你没有资格随便买了一张彩票，就要求中大奖。自己都活不明白的人，生小孩改变不了自己的人生，还只会连累到孩子，贫贱夫妻百事哀，想改变人生，只能靠自己。</em></p><p>第一篇博文唠唠叨叨了很多，再加上近期经历得很多，思考了很多，对于教育，对于人生。这里面存在很多我个人的局限性，也和我的经历息息相关。偷懒的兔子，已经在路边睡了好多年，虽然现在亡羊补牢还为时未晚，但必须要跑起来了。立一个flag，博客的事，从今天开始，这次一定，坚持下去。不管未来的路我会怎么走，<strong><em>奋进是我的主旋律！</em></strong></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/labi.jpg" srcset="/img/loading.gif" alt></p><hr><h2 id="先从leetcode算法题的学习开始："><a href="#先从leetcode算法题的学习开始：" class="headerlink" title="先从leetcode算法题的学习开始："></a><font face="楷体">先从leetcode算法题的学习开始：</font></h2><p><em>熟练掌握算法题，不仅要学会算法中的思想，更要多练，这是一个熟能生巧的过程。</em></p><p><em>下面题目均来源于<a href="https://leetcode-cn.com" target="_blank" rel="noopener">https://leetcode-cn.com</a></em></p><h4 id="类别一：数组的简单应用"><a href="#类别一：数组的简单应用" class="headerlink" title="类别一：数组的简单应用"></a><em>类别一：数组的简单应用</em></h4><h5 id="1、两数之和（easy）"><a href="#1、两数之和（easy）" class="headerlink" title="1、两数之和（easy）"></a>1、两数之和（easy）</h5><p><em>题目描述：</em></p><p>给定一个整数数组 <code>nums</code> 和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc1.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>最简单，也是最直接的想法，先选定数组中的一个数，再通过遍历取得数组中剩下的另一个数。由于答案唯一，只要如此遍历一遍，一定能找到答案。但这样的做法问题在于时间复杂度很高,达到了<em>O</em>（n^2），当数组给定量很大时，用时会非常的高。</p><p>这里我们考虑利用c++的STL提供的<strong>map</strong>关联容器进行解答。根据百度百科中的描述，map提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可以称为该关键字的值）的数据处理能力，其内部是一个自建的红黑树（这个知识点之后一定要学习一下），这样在进行数据查找的时候，时间复杂度就能降到<em>O</em>（1）的水平，也就是我们所说的哈希查找。</p><p>判断一个数据是否在map中，我们可以通过两种形式进行判断，</p><p><code>map.find(target) != m.end();</code>  这里是判断map的迭代器是否走到了最后，即map中不存在<code>target</code>。</p><p><code>map.count(target) == 1;</code></p><p>所以据此的解决方案即为：依次将数组元素读入map中，并将第二项元素设置为所对应数组中元素位置编号。在读入之前判断<code>target-nums[i]</code>一项是否存在，这样可以消除重复判断新读入的元素而造成重复利用数组中的同样元素。当然每道题都要考虑边界条件，本题要考虑这样的一对整数不存在，需要返回空数组。</p><p><em>最终代码：</em></p><pre><code class="c++">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        map&lt;int, int&gt; m;        for(int i = 0; i &lt; nums.size(); i++){            if(m.find(target - nums[i]) != m.end())                return {m[target - nums[i]], i};            m[nums[i]] = i;        }        return {};    }</code></pre><h5 id="11、盛最多水的容器-medium"><a href="#11、盛最多水的容器-medium" class="headerlink" title="11、盛最多水的容器(medium)"></a>11、盛最多水的容器(medium)</h5><p><em>题目描述：</em></p><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc11.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>在数组中进行操作往往与双指针密不可分，本题对于双指针的应用很简单，由于确定的面积为较矮的那一边决定的，这就符合木桶原理，我们只要通过矮边与两边距离就可以确定容器可装水量，而双指针的修改也是每次将矮的那边向中心移动一格。</p><p><em>最终代码</em></p><pre><code class="c++">int maxArea(vector&lt;int&gt;&amp; height) {        int len = height.size();        int i = 0, j = len-1;        int max = 0;        while(i &lt; j){            int dwarf = height[i] &lt; height[j] ?height[i]:height[j];            int area = dwarf * (j - i);            if(area &gt; max)                max = area;            if(height[i] &lt; height[j])                i++;            else                j--;        }        return max;    }</code></pre><h5 id="15、三数之和-medium"><a href="#15、三数之和-medium" class="headerlink" title="15、三数之和(medium)"></a>15、三数之和(medium)</h5><p><em>题目描述：</em></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc15.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>首先说明，本题代码我反复出错，并且最后写的又臭又长，参考价值不大。简单的来说，本题依旧是一道双指针的题目。与第一题的区别在于本题这样的组合不止一组，我们需要全部输出。值得注意的是，由于三元组中可能存在相等的元素，所以在最后输出的集合中会有重复的集合存在，可以用erase函数进行删除重复（我后半段代码就实现了这个功能，但不如直接调用）。如何确定指针该指向何处呢？其实就是在求两数之和的基础上，先确定一个数<code>a</code>，那么<code>target-a</code>即为两数之和的求解。</p><p><em>最终代码</em></p><pre><code class="c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; ans;        vector&lt;int&gt; vtemp;        int len = nums.size();        if(len &lt; 3)            return ans;        sort(nums.begin(), nums.end());        for(int i = 0; i &lt; len-2; i++){            if(nums[i] &gt; 0)                break;            int mem1 = nums[i];            int j = i+1, k = len-1;            while(j &lt; k){                int sum = nums[i] + nums[j] + nums[k];                if(sum == 0){                    vector&lt;int&gt; vtemp{nums[i], nums[j], nums[k]};                    ans.push_back(vtemp);                    vtemp.clear();                    j++;                }                else if(sum &lt; 0 &amp;&amp; j &lt; k){                    j++;                }                else if(sum &gt; 0 &amp;&amp; j &lt; k){                    k--;                }            }            while(mem1 == nums[i+1] &amp;&amp; i &lt; len-3){                if(i &lt; len-3)                    i++;            }        }        sort(ans.begin(), ans.end());        vector&lt;vector&lt;int&gt;&gt; ans2;        int count = ans.size();        if(count == 0)            return ans2;        int las1 = ans[0][0], las2 = ans[0][1], las3 = ans[0][2];        ans2.push_back(ans[0]);        for(int i = 1; i &lt; count; i++){            if(ans[i][0] != las1 || ans[i][1] != las2 || ans[i][2] != las3){                ans2.push_back(ans[i]);                las1 = ans[i][0];                las2 = ans[i][1];                las3 = ans[i][2];            }        }        return ans2;    }</code></pre><h5 id="31、下一个排列-medium"><a href="#31、下一个排列-medium" class="headerlink" title="31、下一个排列(medium)"></a>31、下一个排列(medium)</h5><p><em>题目描述：</em></p><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p><em>示例：</em></p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><p><em>思考：</em></p><p><em>最终代码</em></p><pre><code class="c++">void nextPermutation(vector&lt;int&gt;&amp; nums) {        int len = nums.size();        if(len == 0 || len == 1)            return;        bool max = true;        for(int i = 0; i &lt; len-1; i++){            if(nums[i] &lt; nums[i+1])                max = false;        }        if(max){            sort(nums.begin(), nums.end());            return;        }        vector&lt;int&gt;::iterator j = nums.end()-2;        while(j &gt;= nums.begin()){            if(*j == nums[len-1])                j--;            else                break;        }        if(*j &lt; nums[len-1]){            int temp = nums[len-1];            nums[len-1] = *j;            *j = temp;            sort(j+1, nums.end());            return;        }        else{            while(*(j-1) &gt;= *j){                j--;            }            vector&lt;int&gt;::iterator i = nums.end()-1;            while(*i &lt;= *(j-1)){                i--;            }            int temp2 = *i;            *i = *(j-1);            *(j-1) = temp2;            sort(j, nums.end());            return;        }    }</code></pre><hr><h4 id="类别二：链表的简单应用"><a href="#类别二：链表的简单应用" class="headerlink" title="类别二：链表的简单应用"></a><em>类别二：链表的简单应用</em></h4><h5 id="2、两数相加-medium"><a href="#2、两数相加-medium" class="headerlink" title="2、两数相加(medium)"></a>2、两数相加(medium)</h5><p><em>题目描述：</em></p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储一位数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc2.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>链表与顺序表的区别在于，链表的每一个结点信息，必须依靠上一个结点信息才能获得。而整数之间相加，考虑的重点就是进位。本题中，由于链表本身就是逆序放置，我们只需要从链表首结点开始依次加入L1，L2的结点值，这里既可以新生成一个结点用于保存，也可以用原结点。同时需要一个格外的bool型变量用于确定是否发生了进位。由于L1，L2链表长度不一定相等，同时在链表尾也存在进位的可能，所以要注意最后若<code>count ==1</code>需要对结尾处再增加一个结点。</p><p><em>最终代码</em></p><pre><code class="c++">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {        ListNode*  T = new ListNode(-1);        ListNode* head = T;        bool count = false;        while(l1 != NULL || l2 != NULL){            int  sum = 0;            if(l1 != NULL){                sum = sum + l1-&gt;val;                l1 = l1-&gt;next;            }            if(l2 != NULL){                sum = sum + l2-&gt;val;                l2 = l2-&gt;next;            }            if(count){                sum++;            }            T-&gt;next = new ListNode(sum%10);            T = T-&gt;next;            count = sum &gt; 9 ?true:false;        }        if(count){            T-&gt;next = new ListNode(1);        }        return head-&gt;next;    }</code></pre><h5 id="19、删除链表的倒数第N个节点-medium"><a href="#19、删除链表的倒数第N个节点-medium" class="headerlink" title="19、删除链表的倒数第N个节点(medium)"></a>19、删除链表的倒数第N个节点(medium)</h5><p><em>题目描述：</em></p><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc19.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>本题既是一道链表的简单应用，也是一道双指针的题目。如何确定倒数第n个节点，其实就是找到倒数第n+1个节点的位置。思路就是设置两个指针，一个先走n+1步，然后两者开始同时移动，当先走的指针指向链表尾时，后走的指针正好指向倒数第n+1处。</p><p><em>最终代码</em></p><pre><code class="c++">ListNode* removeNthFromEnd(ListNode* head, int n) {        ListNode* p;        ListNode* q;        ListNode* r;        p = head;        q = head;        if(p-&gt;next == NULL &amp;&amp; n == 1){            head = NULL;            return head;        }        while(n &gt; 0){            p = p-&gt;next;            n--;        }        if(p == NULL){            head = head-&gt;next;            return head;        }        while(p-&gt;next != NULL){            q = q-&gt;next;            p = p-&gt;next;        }        r = q-&gt;next;        if(r-&gt;next == NULL)            q-&gt;next = NULL;        else            q-&gt;next = r-&gt;next;        return head;    }</code></pre><h5 id="23、合并K个排序链表-hard"><a href="#23、合并K个排序链表-hard" class="headerlink" title="23、合并K个排序链表(hard)"></a>23、合并K个排序链表(hard)</h5><p><em>题目描述：</em></p><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc23.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>这道题目归为hard，其实并不难，属于一道综合问题。题目的基础是两个链表有序排列，由此引申出题目的解题方法有很多种，可以每次加入一个链表，直到全部加入其中，但这样做时间复杂度高。很容易地想到归并排序，将链表两两一组，2，4，8，16。。。逐渐完成全部的有序化，值得注意的是要对k的奇偶性做出讨论。同时我学到的还有在c++中，nullptr表示空指针。</p><p><em>最终代码</em></p><pre><code class="c++">ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {        ListNode* res;        int k = lists.size();        if(lists.empty()){            return nullptr;        }        else if(k == 1){            return lists[0];        }        else{            while(k &gt; 1){                int count;                if(k % 2){                    count = k - 1;                }                else                        count = k;                for(int i = 0; i &lt; count; i++){                    lists[i/2] = mergetwo(lists[i], lists[i+1], lists);                    i++;                }                if(k % 2){                    lists[k/2] = lists[k-1];                    k = k / 2 + 1;                }                else                    k = k / 2;            }            return lists[0];        }    }    ListNode* mergetwo(ListNode* l1, ListNode* l2, vector&lt;ListNode*&gt;&amp; lists) {        ListNode* ans;        ListNode* p;        if(l1 == NULL &amp;&amp; l2 == NULL)            return ans;        else if(l1 != NULL &amp;&amp; l2 == NULL)            return l1;        else if(l1 == NULL &amp;&amp; l2 != NULL)            return l2;        if(l1-&gt;val &lt;= l2-&gt;val){            ans = l1;            l1 = l1-&gt;next;            p = ans;        }        else{            ans = l2;            l2 = l2-&gt;next;            p = ans;        }        while(l1 != NULL &amp;&amp; l2 !=NULL){            if(l1-&gt;val &lt;= l2-&gt;val){                p-&gt;next = l1;                l1 = l1-&gt;next;                p = p-&gt;next;            }            else{                p-&gt;next = l2;                l2 = l2-&gt;next;                p = p-&gt;next;            }        }        if(l1 != NULL){            p-&gt;next = l1;        }        if(l2 != NULL){            p-&gt;next = l2;        }        return ans;</code></pre><h5 id="25、-K-个一组翻转链表-hard"><a href="#25、-K-个一组翻转链表-hard" class="headerlink" title="25、 K 个一组翻转链表(hard)"></a>25、 K 个一组翻转链表(hard)</h5><p><em>题目描述：</em></p><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>说明：</p><p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><em>示例：</em></p><p>给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p><em>思考：</em></p><p>我在这道题的实现中没有完成题目中常数额外空间的要求，而是模拟地将每k个节点先保存起来，再倒序链接起来。其实这里完全可以稍做修改，先确定剩下的节点是否有k个，再从开始处挨个倒转。当走到每个k个一组的最后一项时，再将上一组节点的第一项与其相连即可。若剩下的节点不足，则不进行变化。</p><p><em>最终代码</em></p><pre><code class="c++">ListNode* reverseKGroup(ListNode* head, int k) {        if(head == NULL)            return head;        ListNode* ans = new ListNode(-1);;        ListNode* p;        p = ans;        vector&lt;ListNode*&gt; temp;        int n = k;        while(head != NULL){            while(k){                if(head == NULL)                    break;                else{                    temp.push_back(head);                }                head = head-&gt;next;                k--;            }            if(temp.size() &lt; n)                break;            else if(temp.size() == n){                int i = n-1;                while(!temp.empty()){                    p-&gt;next = temp[i];                    temp.pop_back();                    p = p-&gt;next;                    i--;                }            }            k = n;        }        if(temp.empty())            p-&gt;next = nullptr;        else{            for(int i = 0; i &lt; temp.size(); i++){                p-&gt;next = temp[i];                p = p-&gt;next;            }            p-&gt;next = nullptr;        }        return ans-&gt;next;    }</code></pre><hr><h4 id="类别三：字符串的简单应用"><a href="#类别三：字符串的简单应用" class="headerlink" title="类别三：字符串的简单应用"></a><em>类别三：字符串的简单应用</em></h4><h5 id="3、无重复字符的最长子串-medium"><a href="#3、无重复字符的最长子串-medium" class="headerlink" title="3、无重复字符的最长子串(medium)"></a>3、无重复字符的最长子串(medium)</h5><p><em>题目描述：</em></p><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc3.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>题目要求取得不含重复字符的最长子串，我开始给出的方案就是按照从头到尾的顺序，依次作为子串开头，然后再进行一遍循环判断子串长度，当然我们这里判断是否出现了重复字符的手段为将<code>i</code>作为子串的最后一个字符，而将<code>p</code>指向子串的第一个字符，这样当向后遍历时，若出现重复可以通过<code>p = j+1</code>的手段减少<code>j</code>的循环次数。但毫无疑问，这个方法属于暴力解，时间复杂度达到了<em>O</em>（n^2）。那么有没有<em>O</em>（n）的时间复杂度呢？当然有，但同时代价是空间复杂度也达到了<em>O</em>（n）。方法就是依靠滑动窗口思想，并利用c++提供的关联容器<code>unordered_set</code>来进行存储已存在的字符，右指针通过不断读入新字符，当出现重复字符时，通过移动左指针来消除重复字符，由于<code>unordered_set</code>采用hash表进行查找，所以时间复杂度为<em>O</em>（1），则综合时间复杂度为<em>O</em>（n）。相关代码略。</p><p><em>最终代码</em></p><pre><code class="c++">int lengthOfLongestSubstring(string s) {        int l = s.length();        if(l == 0)            return 0;        int p = 0;        int max = 1;        for(int i = 0; i &lt; l; i++){            for(int j = p; j &lt; i; j++){                if(s[j] == s[i]){                    p = j + 1;                }            }            int count = i - p + 1;            if(count &gt; max)                max = count;        }        return max;    }</code></pre><h5 id="5、最长回文子串-medium"><a href="#5、最长回文子串-medium" class="headerlink" title="5、最长回文子串(medium)"></a>5、最长回文子串(medium)</h5><p><em>题目描述：</em></p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc5.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>回文串是算法题目中特别常见的题目，证明一个串是回文串的方法，既可以从两端向中间移动，也可以由中心向两端扩展，而为了减少重复判断的内容，显然后者更加适合判断回文串。这里有一点需要注意的是，由中心扩展存在两个问题，奇数中心与偶数中心，所以这两种情况均需要考虑。此时时间复杂度为<em>O</em>（n^2）。同时，此类题也有另外的解决办法，那就是动态规划，动态规划适合做什么样的题呢？就是可以把题目分隔开，假设字符串总长度100，那么我只要知道前99的结果，再把第100加入判断，就可以得到前100的结果。这就是数学归纳法的思想。由于本题目动态规划同样要用到一轮确定回文子串长度的遍历，加上总串的逐一遍历，时间复杂度同样为<em>O</em>（n^2），而空间复杂度由于要保存前面所有长度时的结果，同样达到了<em>O</em>（n^2），所有这里我们暂略。</p><p><em>最终代码</em></p><pre><code class="c++">int ifcircle(string&amp; s, int i, int j){        int L = i, R = j;        if(s[L] != s[R])            return 0;        while(s[L] == s[R] &amp;&amp; L &gt; 0 &amp;&amp; R &lt; s.length()-1){            L--;            R++;        }        if(s[L] == s[R])            return R - L + 1;        else             return R - L - 1;    }    string longestPalindrome(string s) {        int n = s.length();        int len1, len2, len;        int begin = 0, end = 0, max = 0;        for(int i = 0; i &lt; n; i++){            len1 = ifcircle(s, i, i);            len2 = ifcircle(s, i, i+1);            len = len1 &gt; len2 ?len1:len2;            if(len &gt; max){                if(len % 2){                    begin = i - (len - 1)/2;                    end = i + (len - 1)/2;                }                else{                    begin = i - (len - 1)/2;                    end = i + len / 2;                }                max = len;            }        }        if(max % 2)            return s.substr(begin, max);        else            return s.substr(begin, max);    }</code></pre><h5 id="6、Z-字形变换-medium"><a href="#6、Z-字形变换-medium" class="headerlink" title="6、Z 字形变换(medium)"></a>6、Z 字形变换(medium)</h5><p><em>题目描述：</em></p><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为<code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p><p>L    C      I      R<br>E T O E  S  I  I  G<br>E    D     H     N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p><code>string convert(string s, int numRows);</code></p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc6.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>本题看似是道字符串的重排列问题，但实际是一道数学题。根据给定的行数，我们来确定每次循环发生转折的字符长度为<code>temp = 2 * (numRows - 1)</code>，在此基础上通过建立对应的坐标转换关系，从而确定原字符串中每个字符对应新排列位置，再依次叠加各层字符得到新的字符串。</p><p><em>最终代码</em></p><pre><code class="c++">string convert(string s, int numRows) {        if(numRows == 1){            return s;        }        int len = s.size();        vector&lt;string&gt; rows(min(numRows, len));        bool turn = false;        int temp = 2 * (numRows - 1);        for(int i = 0; i &lt; len; i++){            int j = i % (temp);            if(j &lt; numRows){                rows[j] += s[i];            }            else if(j &gt;= numRows){                rows[temp-j] += s[i];            }        }        string ans;        for (string row : rows) {// 从上到下遍历行            ans += row;        }        return ans;    }</code></pre><h5 id="10、正则表达式匹配-hard"><a href="#10、正则表达式匹配-hard" class="headerlink" title="10、正则表达式匹配(hard)"></a>10、正则表达式匹配(hard)</h5><p><em>题目描述：</em></p><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc10.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>这道题目是一道比较难的算法题，从题目来看，由于是对字符串匹配进行的一个判断，那么首先可以考虑到的就是动态规划和回溯算法。同时解决的手段可能并不限于递归、深度优先遍历。我在接触这道题目的时候对于回溯算法和动态规划还不够了解，无法做到应用，就采用了当时比较熟悉的递归进行的解答。递归解答的关键就是要确定递归的出口，这里我们确定出口应为s，p两个字符串均读到了最后一位。对于‘.’的匹配相对容易，只要将其作为任意字符即可。而对于‘*’字符来说，考虑的出发点主要在于零次与多次的区别。我的设计角度为设置more与zero的bool型变量，zero的判断依靠p字符串的后数两位字符确定<code>zero = pipei(s, p, x, y+2, len1, len2);</code>，而more的判断建立在非zero的前提下，<code>more = pipei(s, p, x+1, y, len1, len2);</code>。由于两种情况均可能，所以两者应为“或”的关系。值得一提的是，由于zero的判断式，我们存在x为len1-2，y为len2-2的情况，此时y+2为len2超出了边界条件。我的处理方式为在p字符串尾加入一个与所判断字符均不相同的字符（这里我加了”A”）。如果有时间可以用回溯或动态规划对题目重写。</p><p><em>最终代码</em></p><pre><code class="c++">bool pipei(string&amp; s, string&amp; p, int x, int y, int len1, int len2){        if(x == len1){            if(y == len2){                //cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;                return true;            }            }        bool more = false, zero = false;        if(p[y+1] == &#39;*&#39; &amp;&amp; y + 1 &lt; len2){            zero = pipei(s, p, x, y+2, len1, len2);            //cout &lt;&lt; x &lt;&lt; y &lt;&lt; zero &lt;&lt; more &lt;&lt; endl;            if(zero == false &amp;&amp; (x &lt; len1) &amp;&amp; (s[x] == p[y] || p[y] == &#39;.&#39;)){                more = pipei(s, p, x+1, y, len1, len2);                //cout &lt;&lt; x &lt;&lt; y &lt;&lt; zero &lt;&lt; more &lt;&lt; endl;            }            return zero || more;        }        else{            if((x &lt; len1) &amp;&amp; (s[x] == p[y] || p[y] == &#39;.&#39;)){                //cout &lt;&lt; x &lt;&lt; y &lt;&lt; zero &lt;&lt; more &lt;&lt; endl;                return pipei(s, p, x+1, y+1, len1, len2);            }            else{                //cout &lt;&lt; x &lt;&lt; y &lt;&lt; zero &lt;&lt; more &lt;&lt; endl;                return false;            }        }        return false;    }    bool isMatch(string s, string p) {          int len1 = s.size();        int len2 = p.size();        p = p + &#39;A&#39;;        bool ans = pipei(s, p, 0, 0, len1, len2);        return ans;    }</code></pre><h5 id="30、串联所有单词的子串-hard"><a href="#30、串联所有单词的子串-hard" class="headerlink" title="30、串联所有单词的子串(hard)"></a>30、串联所有单词的子串(hard)</h5><p><em>题目描述：</em></p><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc30.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>本题给出的解决方法，是基于哈希表的匹配查找机制。思路很简单，由于子串长度为<code>wid*W</code>，那么外层循环的范围应该为<code>for(int i = 0; i &lt;= len-wid*W; i++)</code>，而对于每次循环，都一一对由<code>words</code>中所有元素组成的哈希表进行比对，若比对成功则满足输出条件，输出此时的<code>i</code>。本题思路清晰，不过当字符串总长度很长时，循环幅度很大，而从原字符串中截取<code>word</code>大小的子字符串也花费很多时间，总的来说时间复杂度还是偏高的。</p><p><em>最终代码</em></p><pre><code class="c++">vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {        vector&lt;int&gt; ans;        int len = s.size();     //特殊情况         if(len == 0)            return ans;        int wid = words.size();        if(wid == 0)            return ans;        int W = words[0].size();        if(W == 0)            return ans;        if(len &lt; wid*W)            return ans;        unordered_map&lt;string, int&gt; bz;        unordered_map&lt;string, int&gt; temp;        for(string t:words)            bz[t]++;        for(int i = 0; i &lt;= len-wid*W; i++){            temp = bz;            int j = 0;            while(j &lt; wid){                string xyz = s.substr(i+j*W, W);                if(temp[xyz] &gt; 0)                    temp[xyz]--;                else                    break;                j++;            }            if(j == wid)                ans.push_back(i);        }        //sort(ans.begin(), ans.end());        return ans;    }</code></pre><hr><h4 id="类别四：二分查找的应用"><a href="#类别四：二分查找的应用" class="headerlink" title="类别四：二分查找的应用"></a><em>类别四：二分查找的应用</em></h4><h5 id="4、寻找两个有序数组的中位数-hard"><a href="#4、寻找两个有序数组的中位数-hard" class="headerlink" title="4、寻找两个有序数组的中位数(hard)"></a>4、寻找两个有序数组的中位数(hard)</h5><p><em>题目描述：</em></p><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code>和 <code>nums2</code>不会同时为空。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc4.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>找中位数的题目也是算法中特别常见的，依据其是否有序，可以考虑应用二分查找。本题目要求时间复杂度为<em>O</em>(log(m + n))，那么就必须从二分查找入手考虑问题。（当然还有堆排序、分治算法的方式可能满足O(log(m + n))）不失一般性的，我们可以让短数组为<code>nums1</code>，长数组为<code>nums2</code>（其实无影响），为了最小化时间复杂度，我们考虑这样的情况，一定存在<code>half = (m + n + 1)/2</code>个元素比中位数小的情况。基于这个情况，我们在短数组中计算一个中位数<code>mid1 = (a1 + a2)/2</code>，再在长数组中计算一个<code>mid2 = half - mid1</code>，后续通过两个位置<code>nums1[mid1]</code>，<code>nums2[mid2-1]</code>处的数值大小比较，进而确定中位数在<code>nums1</code>数组中的位置关系，这样的判断方法可以在O(logm）中完成对<code>nums1</code>的数据筛查。</p><p><em>最终代码</em></p><pre><code class="c++">double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        if(nums1.size() &gt; nums2.size())            return findMedianSortedArrays(nums2, nums1);        int m = nums1.size();        int n = nums2.size();        int a1 = 0, a2 = m;        int mid1, mid2, half = (m + n + 1)/2;        while(a1 &lt;= a2){            mid1 = (a1 + a2)/2;            mid2 = half - mid1;            if(mid1 &lt; a2 &amp;&amp; nums2[mid2-1] &gt; nums1[mid1]){                a1 = mid1 + 1;            }            else if(mid1 &gt; a1 &amp;&amp; nums1[mid1-1] &gt; nums2[mid2]){                a2 = mid1 - 1;            }            else{                int maxl = 0;                if(mid1 == 0)                    maxl = nums2[mid2-1];                else if(mid2 == 0)                    maxl = nums1[mid1-1];                else{                    maxl = nums1[mid1-1] &gt; nums2[mid2-1] ?nums1[mid1-1]:nums2[mid2-1];                }                if((m + n) % 2 == 1)                    return maxl;                int maxr = 0;                if(mid1 == m)                    maxr = nums2[mid2];                else if(mid2 == n)                    maxr = nums1[mid1];                else                    maxr = nums1[mid1] &lt; nums2[mid2] ?nums1[mid1]:nums2[mid2];                return (maxl + maxr) / 2.0;            }        }        return 0.0;    }</code></pre><hr><h4 id="类别五：边界条件的考察"><a href="#类别五：边界条件的考察" class="headerlink" title="类别五：边界条件的考察"></a><em>类别五：边界条件的考察</em></h4><h5 id="8、字符串转换整数-atoi-medium"><a href="#8、字符串转换整数-atoi-medium" class="headerlink" title="8、字符串转换整数 (atoi)(medium)"></a>8、字符串转换整数 (atoi)(medium)</h5><p><em>题目描述：</em></p><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc8.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>本题目是属于不难但分析起来特别恶心的那种，由于存在各种各样的边界情况，需要分开讨论。关于字符向数字转变可以由<code>str[i] - &#39;0&#39;</code>实现。其他需要注意的点为：1、不仅“-”可以成为数字开头，“+”同样可以。2、数字在超越整数边界条件的判断（2147483647，-2147483648）。我在当时完成题目时对结果的判断用到了很多bool型，同时存在很多命名问题，使得在后续回顾时对于判断条件云里雾里，这样做存在很大弊端，各位不要学我。</p><p><em>最终代码</em></p><pre><code class="c++">int myAtoi(string str) {        int len = str.size();        int i = 0, num = 0;        bool flag = false;        bool count1 = false;        bool count2 = false;        bool big = false;        bool number = false;        int n = 0;        while(i &lt; len){            if(str[i] == &#39; &#39;){                if(flag == false &amp;&amp; count1 == false &amp;&amp; count2 == false &amp;&amp; number == false)                    n++;                else                    break;            }            else if(str[i] == &#39;-&#39;){                if(flag == false &amp;&amp; count1 == false &amp;&amp; count2 == false &amp;&amp; number == false){      //防止遇到-25-566的情况                    flag = true;                    count1 = true;                }                else                    break;            }            else if(str[i] == &#39;+&#39;){                if(flag == false &amp;&amp; count1 == false &amp;&amp; count2 == false &amp;&amp; number == false){                          count2 = true;                }                else                    break;            }            else if(str[i]&gt;=&#39;0&#39;&amp;&amp;str[i]&lt;=&#39;9&#39;){                number = true;                if(flag == true &amp;&amp; count1 == true &amp;&amp; count2 == false){                    num = 0 - (str[i] - &#39;0&#39;);                    count1 = false;                }                else if((((num == INT_MAX/10) &amp;&amp; (str[i] - &#39;0&#39; &lt;= 7)) || (num &lt; INT_MAX/10))&amp;&amp;(flag == false)){                    num = num * 10;                    num = num + (str[i] - &#39;0&#39;);                }                else if((((num == INT_MIN/10) &amp;&amp; (str[i] - &#39;0&#39; &lt;= 8)) || (num &gt; INT_MIN/10))&amp;&amp;(flag == true)){                    num = num * 10;                    num = num - (str[i] - &#39;0&#39;);                }                else                     big = true;               }            else                break;            i++;        }        if(num){            if(big &amp;&amp; !flag)                return INT_MAX;            else if(big &amp;&amp; flag)                return INT_MIN;            else                return num;        }        else             return 0;    }</code></pre><h5 id="29、两数相除-medium"><a href="#29、两数相除-medium" class="headerlink" title="29、两数相除(medium)"></a>29、两数相除(medium)</h5><p><em>题目描述：</em></p><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 <code>mod</code>运算符。</p><p>返回被除数 <code>dividend</code> 除以除数<code>divisor</code>得到的商。</p><p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code>。</p><p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc29.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>跟边界条件有关，这又是一道繁琐的题目。我对这道题边界条件的分析，更多地就是采取一种枚举的分析方式。首先就是<code>INT_MIN</code>除以<code>-1</code>会产生越界，其次，我通过<code>flag1</code>和<code>flag2</code>分别作为判断被除数和除数的符号位正负性的标志位。而对于<code>INT_MIN</code>越界的问题，我通过设置<code>change</code>标志位来将其转化为<code>INT_MAX</code>进行计算。由于题目要求我们不能用除法、乘法和<code>mod</code>运算符，所以解决除法运算的关键在于位运算，从被除数二进制数的最高位逐渐剥离，直到其小于除数，这样循环累加就能得到商。</p><p><em>最终代码</em></p><pre><code class="c++">int divide(int dividend, int divisor) {        if(dividend == INT_MIN &amp;&amp; divisor == -1)            return INT_MAX;        if(dividend == INT_MIN &amp;&amp; divisor == 1)            return INT_MIN;        if(dividend == INT_MIN &amp;&amp; divisor == INT_MIN)            return 1;        if(dividend &gt; INT_MIN &amp;&amp; divisor == INT_MIN)            return 0;        bool flag1 = false;        bool flag2 = false;        bool change = false;        if(dividend == INT_MIN){            dividend = INT_MAX;            change = true;            flag1 = true;        }        if(dividend &lt; 0){            dividend = 0 - dividend;            flag1 = true;        }        if(divisor &lt; 0){            divisor = 0 - divisor;            flag2 = true;        }        if(dividend &lt; divisor)            return 0;        int count = 0;        while(dividend &gt;= divisor){            int temp = divisor;            int temp_count = 1;            while((dividend &gt;= (temp &lt;&lt; 1)) &amp;&amp; (temp &lt; INT_MAX/2)){                temp = temp &lt;&lt; 1;                temp_count = temp_count &lt;&lt; 1;            }            dividend = dividend - temp;            count = count + temp_count;        }        if(change){            dividend++;            if(dividend == divisor)                count++;        }        if((flag1 &amp;&amp; flag2) || (!flag1 &amp;&amp; !flag2))            return count;        else             return 0 - count;    }</code></pre><hr><h4 id="类别六：回溯算法的应用"><a href="#类别六：回溯算法的应用" class="headerlink" title="类别六：回溯算法的应用"></a><em>类别六：回溯算法的应用</em></h4><h5 id="17、电话号码的字母组合-medium"><a href="#17、电话号码的字母组合-medium" class="headerlink" title="17、电话号码的字母组合(medium)"></a>17、电话号码的字母组合(medium)</h5><p><em>题目描述：</em></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc17-A.png" srcset="/img/loading.gif" alt></p><p><em>示例：</em></p><p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc17-B.png" srcset="/img/loading.gif" alt></p><p><em>思考：</em></p><p>本题是一道经典的回溯问题，何谓回溯，就是我试着走，走错了再反悔就是了。关键步骤就是在尝试与撤销中。如果尝试成功，那么我就继续试，直到得到答案；如果尝试失败，我就撤销这次尝试，更换新的尝试。回溯算法适合输出多组满足条件的集合值。本题中依靠数字来映射不同的字母，就完美符合回溯思想，映射完一项映射下一项，直到全部映射完毕。</p><p><em>最终代码</em></p><pre><code class="c++">vector&lt;string&gt; letterCombinations(string digits) {        vector&lt;string&gt; ans;        vector&lt;string&gt; number = {            &quot;abc&quot;,&quot;def&quot;,            &quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,            &quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;        };        vector&lt;int&gt; num;        int len = digits.size();        if(len == 0)            return ans;        for(int i = 0; i &lt; len; i++){            num.push_back(digits[i] - &#39;2&#39;);        }        string s;        backtrack(len, 0, s, ans, number, num);        sort(ans.begin(), ans.end());        return ans;    }    void backtrack(int len, int n, string &amp;s, vector&lt;string&gt; &amp;ans, vector&lt;string&gt; &amp;number, vector&lt;int&gt; &amp;num){        if(n == len){            ans.push_back(s);            return;        }        int count = number[num[n]].size();        for(int j = 0; j &lt; count; j++){            s.push_back(number[num[n]][j]);            backtrack(len, n+1, s, ans, number, num);            s.pop_back();          }    }</code></pre><hr><h4 id="类别四：二分查找的应用-1"><a href="#类别四：二分查找的应用-1" class="headerlink" title="类别四：二分查找的应用"></a><em>类别四：二分查找的应用</em></h4><h5 id="4、寻找两个有序数组的中位数-hard-1"><a href="#4、寻找两个有序数组的中位数-hard-1" class="headerlink" title="4、寻找两个有序数组的中位数(hard)"></a>4、寻找两个有序数组的中位数(hard)</h5><p><em>题目描述：</em></p><p><em>示例：</em></p><p><em>思考：</em></p><p><em>最终代码</em></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法的学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
