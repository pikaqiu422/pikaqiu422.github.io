<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>皮卡丘422的第一篇个人博客 - 爱学习的皮卡皮卡</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>爱学习的皮卡皮卡</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期二, 三月 24日 2020, 10:01 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    9.2k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      38 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <h1 id="皮卡丘422的第一篇个人博客"><a href="#皮卡丘422的第一篇个人博客" class="headerlink" title="皮卡丘422的第一篇个人博客"></a><font face="楷体"><center>皮卡丘422的第一篇个人博客</center></font></h1><h4 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h4><p>如果有人跟十年前的我说，二十多岁是人生最难的十年，我肯定不屑一顾。小时候的自己就觉得成年人有多么多么好，多么多么自由。可就是太自由了，人生才容易失去方向。学生思维的三大局限，或者说是人性的弱点——<strong><em>终点型思维，秘籍型思维和空杯型思维</em></strong>，（理论参考知乎用户柴桑）而现在的我，对<strong>终点型思维</strong>有了更深刻的理解。</p>
<p>第二次与北大失之交臂，可笑的单科线，成了压死骆驼的最后一根稻草。被迫开始考虑找工作，开始研究技术，开始不断充电学习。蓦然回首，我突然发现自己竟然早已陷入了这样的思维之中很深很深。为什么要考北大呢？一半的名校梦，一半的“北大研究生出来就能怎样怎样”。<strong>若不是迫不得已转向的招聘一事给了我当头一棒，我不知还要沉浸在这种思想中多久</strong>。诚然，一所名校的高学历不仅代表着高智商，也往往代表着高能力。不可否认的是，从名校毕业的学生也往往是同龄人里最优秀的，但这份优秀不是源自于名校身份赋予了他多少，而是在于他在名校的环境中学到了多少。这里提名我的大学寝室长，目前就读于哈尔滨工业大学深圳研究院的cs专硕。从毕业后这一年中间歇性的交流之中，我有理由相信，也是毫不夸张的说，他在哈工的这一年，比他在电子科大的四年，包括大四上的考研，所付出的全部还要多很多。他日常会在寝室群里说，同门了，同学了都太厉害了，自己差的很远，得追。至于后面哪怕是疫情阶段，无法返校，他在家的学习生活都是7-12-7。我不知道他都具体学到了什么，但有一点我可以确信，就是他知道了人生要努力，并在努力的路上不断地前行着。</p>
<p>或许现在意识到这点还不晚。虽然从古至今有太多的文学作品劝人努力，催人奋进，但真的只有一个人切身走到那一步了，无路可退了，才能真的意识到<strong>努力的重要性</strong>。我从小就是一个靠着天赋和老师推着走的学生。娱乐的手段千千万，而学习之路就是完任务。当然，这也局限于家庭、环境所给我带来的学习局限性，我不知道什么是编程，什么是算法，除了语数外政史地生，还有什么东西是一个人的成长应该要学的。老师会跟你说，坚持到大学就解放了；父母会跟你说，学习这条路就是把学校的东西学好。所以我的大学生活，和很多人一样，没有挂科，也没啥荣誉，唯一奋斗过的一段时光，就是大二组队争取了一个大学生建模的省一。作为一个cs科班出身的学生，在大学毕业码过的代码也不过千余行，想想也是可笑。至于走到如今这个时间点，点开许多同龄人的博客、简历，才知道自己四年时间被拉开了多少个身位。</p>
<p>努力不是头悬梁，锥刺股那么夸张，而是在一个<strong>该学习的时间段去学习，该奋斗的时间段去奋斗</strong>，这点，是我这两年考研经历所教会我的全部。人生也不是向着终点前进，而是一场起点不一样的长跑，跑得远的不代表了胜利，跑得久的才是。<em>这里多嘴一句，教育是个奢侈品，对于任何家庭都是。它贵在的，不仅是昂贵的学区房、一线城市户口、优质的教育资源，更是家长能带给子女的眼界，能否做到以身作则的表率。如果家长嘴里只有：把学校的东西学会了，就够了；小孩子没有隐私权，我说让你干什么，你就干什么；什么是编程，什么是宇宙，什么是量子力学，我不懂，你自己看去；看电视剧是大人的权力，我们才能看，你去学习去，我们老了，学不动了；养儿防老，不孝有三，无后为大等等。那么我请您再好好思考一下，您真的要生这个孩子吗？如果要生，那么在孩子的成长过程中，当你提到别人家的小孩如此怎样的时候，当你望子成龙，望女成凤的时候，请你闭嘴，你没有资格随便买了一张彩票，就要求中大奖。自己都活不明白的人，生小孩改变不了自己的人生，还只会连累到孩子，贫贱夫妻百事哀，想改变人生，只能靠自己。</em></p>
<p>第一篇博文唠唠叨叨了很多，再加上近期经历得很多，思考了很多，对于教育，对于人生。这里面存在很多我个人的局限性，也和我的经历息息相关。偷懒的兔子，已经在路边睡了好多年，虽然现在亡羊补牢还为时未晚，但必须要跑起来了。立一个flag，博客的事，从今天开始，这次一定，坚持下去。不管未来的路我会怎么走，<strong><em>奋进是我的主旋律！</em></strong></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/labi.jpg" srcset="/img/loading.gif" alt></p>
<hr>
<h2 id="先从leetcode算法题的学习开始："><a href="#先从leetcode算法题的学习开始：" class="headerlink" title="先从leetcode算法题的学习开始："></a><font face="楷体">先从leetcode算法题的学习开始：</font></h2><p><em>熟练掌握算法题，不仅要学会算法中的思想，更要多练，这是一个熟能生巧的过程。</em></p>
<p><em>下面题目均来源于<a href="https://leetcode-cn.com" target="_blank" rel="noopener">https://leetcode-cn.com</a></em></p>
<h4 id="类别一：数组的简单应用"><a href="#类别一：数组的简单应用" class="headerlink" title="类别一：数组的简单应用"></a><em>类别一：数组的简单应用</em></h4><h5 id="1、两数之和（easy）"><a href="#1、两数之和（easy）" class="headerlink" title="1、两数之和（easy）"></a>1、两数之和（easy）</h5><p><em>题目描述：</em></p>
<p>给定一个整数数组 <code>nums</code> 和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc1.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>最简单，也是最直接的想法，先选定数组中的一个数，再通过遍历取得数组中剩下的另一个数。由于答案唯一，只要如此遍历一遍，一定能找到答案。但这样的做法问题在于时间复杂度很高,达到了<em>O</em>（n^2），当数组给定量很大时，用时会非常的高。</p>
<p>这里我们考虑利用c++的STL提供的<strong>map</strong>关联容器进行解答。根据百度百科中的描述，map提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可以称为该关键字的值）的数据处理能力，其内部是一个自建的红黑树（这个知识点之后一定要学习一下），这样在进行数据查找的时候，时间复杂度就能降到<em>O</em>（1）的水平，也就是我们所说的哈希查找。</p>
<p>判断一个数据是否在map中，我们可以通过两种形式进行判断，</p>
<p><code>map.find(target) != m.end();</code>  这里是判断map的迭代器是否走到了最后，即map中不存在<code>target</code>。</p>
<p><code>map.count(target) == 1;</code></p>
<p>所以据此的解决方案即为：依次将数组元素读入map中，并将第二项元素设置为所对应数组中元素位置编号。在读入之前判断<code>target-nums[i]</code>一项是否存在，这样可以消除重复判断新读入的元素而造成重复利用数组中的同样元素。当然每道题都要考虑边界条件，本题要考虑这样的一对整数不存在，需要返回空数组。</p>
<p><em>最终代码：</em></p>
<pre><code class="c++">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        map&lt;int, int&gt; m;
        for(int i = 0; i &lt; nums.size(); i++){
            if(m.find(target - nums[i]) != m.end())
                return {m[target - nums[i]], i};
            m[nums[i]] = i;
        }
        return {};
    }</code></pre>
<h5 id="11、盛最多水的容器-medium"><a href="#11、盛最多水的容器-medium" class="headerlink" title="11、盛最多水的容器(medium)"></a>11、盛最多水的容器(medium)</h5><p><em>题目描述：</em></p>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc11.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>在数组中进行操作往往与双指针密不可分，本题对于双指针的应用很简单，由于确定的面积为较矮的那一边决定的，这就符合木桶原理，我们只要通过矮边与两边距离就可以确定容器可装水量，而双指针的修改也是每次将矮的那边向中心移动一格。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">int maxArea(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        int i = 0, j = len-1;
        int max = 0;
        while(i &lt; j){
            int dwarf = height[i] &lt; height[j] ?height[i]:height[j];
            int area = dwarf * (j - i);
            if(area &gt; max)
                max = area;
            if(height[i] &lt; height[j])
                i++;
            else
                j--;
        }
        return max;
    }</code></pre>
<h5 id="15、三数之和-medium"><a href="#15、三数之和-medium" class="headerlink" title="15、三数之和(medium)"></a>15、三数之和(medium)</h5><p><em>题目描述：</em></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc15.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>首先说明，本题代码我反复出错，并且最后写的又臭又长，参考价值不大。简单的来说，本题依旧是一道双指针的题目。与第一题的区别在于本题这样的组合不止一组，我们需要全部输出。值得注意的是，由于三元组中可能存在相等的元素，所以在最后输出的集合中会有重复的集合存在，可以用erase函数进行删除重复（我后半段代码就实现了这个功能，但不如直接调用）。如何确定指针该指向何处呢？其实就是在求两数之和的基础上，先确定一个数<code>a</code>，那么<code>target-a</code>即为两数之和的求解。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; ans;
        vector&lt;int&gt; vtemp;
        int len = nums.size();
        if(len &lt; 3)
            return ans;
        sort(nums.begin(), nums.end());
        for(int i = 0; i &lt; len-2; i++){
            if(nums[i] &gt; 0)
                break;
            int mem1 = nums[i];
            int j = i+1, k = len-1;
            while(j &lt; k){
                int sum = nums[i] + nums[j] + nums[k];
                if(sum == 0){
                    vector&lt;int&gt; vtemp{nums[i], nums[j], nums[k]};
                    ans.push_back(vtemp);
                    vtemp.clear();
                    j++;
                }
                else if(sum &lt; 0 &amp;&amp; j &lt; k){
                    j++;
                }
                else if(sum &gt; 0 &amp;&amp; j &lt; k){
                    k--;
                }
            }
            while(mem1 == nums[i+1] &amp;&amp; i &lt; len-3){
                if(i &lt; len-3)
                    i++;
            }
        }
        sort(ans.begin(), ans.end());
        vector&lt;vector&lt;int&gt;&gt; ans2;
        int count = ans.size();
        if(count == 0)
            return ans2;
        int las1 = ans[0][0], las2 = ans[0][1], las3 = ans[0][2];
        ans2.push_back(ans[0]);
        for(int i = 1; i &lt; count; i++){
            if(ans[i][0] != las1 || ans[i][1] != las2 || ans[i][2] != las3){
                ans2.push_back(ans[i]);
                las1 = ans[i][0];
                las2 = ans[i][1];
                las3 = ans[i][2];
            }
        }
        return ans2;
    }</code></pre>
<h5 id="31、下一个排列-medium"><a href="#31、下一个排列-medium" class="headerlink" title="31、下一个排列(medium)"></a>31、下一个排列(medium)</h5><p><em>题目描述：</em></p>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p><em>示例：</em></p>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1</code></pre><p><em>思考：</em></p>
<p><em>最终代码</em></p>
<pre><code class="c++">void nextPermutation(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len == 0 || len == 1)
            return;
        bool max = true;
        for(int i = 0; i &lt; len-1; i++){
            if(nums[i] &lt; nums[i+1])
                max = false;
        }
        if(max){
            sort(nums.begin(), nums.end());
            return;
        }
        vector&lt;int&gt;::iterator j = nums.end()-2;
        while(j &gt;= nums.begin()){
            if(*j == nums[len-1])
                j--;
            else
                break;
        }
        if(*j &lt; nums[len-1]){
            int temp = nums[len-1];
            nums[len-1] = *j;
            *j = temp;
            sort(j+1, nums.end());
            return;
        }
        else{
            while(*(j-1) &gt;= *j){
                j--;
            }
            vector&lt;int&gt;::iterator i = nums.end()-1;
            while(*i &lt;= *(j-1)){
                i--;
            }
            int temp2 = *i;
            *i = *(j-1);
            *(j-1) = temp2;
            sort(j, nums.end());
            return;
        }
    }</code></pre>
<hr>
<h4 id="类别二：链表的简单应用"><a href="#类别二：链表的简单应用" class="headerlink" title="类别二：链表的简单应用"></a><em>类别二：链表的简单应用</em></h4><h5 id="2、两数相加-medium"><a href="#2、两数相加-medium" class="headerlink" title="2、两数相加(medium)"></a>2、两数相加(medium)</h5><p><em>题目描述：</em></p>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储一位数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc2.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>链表与顺序表的区别在于，链表的每一个结点信息，必须依靠上一个结点信息才能获得。而整数之间相加，考虑的重点就是进位。本题中，由于链表本身就是逆序放置，我们只需要从链表首结点开始依次加入L1，L2的结点值，这里既可以新生成一个结点用于保存，也可以用原结点。同时需要一个格外的bool型变量用于确定是否发生了进位。由于L1，L2链表长度不一定相等，同时在链表尾也存在进位的可能，所以要注意最后若<code>count ==1</code>需要对结尾处再增加一个结点。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode*  T = new ListNode(-1);
        ListNode* head = T;
        bool count = false;
        while(l1 != NULL || l2 != NULL){
            int  sum = 0;
            if(l1 != NULL){
                sum = sum + l1-&gt;val;
                l1 = l1-&gt;next;
            }
            if(l2 != NULL){
                sum = sum + l2-&gt;val;
                l2 = l2-&gt;next;
            }
            if(count){
                sum++;
            }
            T-&gt;next = new ListNode(sum%10);
            T = T-&gt;next;
            count = sum &gt; 9 ?true:false;
        }
        if(count){
            T-&gt;next = new ListNode(1);
        }
        return head-&gt;next;
    }</code></pre>
<h5 id="19、删除链表的倒数第N个节点-medium"><a href="#19、删除链表的倒数第N个节点-medium" class="headerlink" title="19、删除链表的倒数第N个节点(medium)"></a>19、删除链表的倒数第N个节点(medium)</h5><p><em>题目描述：</em></p>
<p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc19.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>本题既是一道链表的简单应用，也是一道双指针的题目。如何确定倒数第n个节点，其实就是找到倒数第n+1个节点的位置。思路就是设置两个指针，一个先走n+1步，然后两者开始同时移动，当先走的指针指向链表尾时，后走的指针正好指向倒数第n+1处。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* p;
        ListNode* q;
        ListNode* r;
        p = head;
        q = head;
        if(p-&gt;next == NULL &amp;&amp; n == 1){
            head = NULL;
            return head;
        }
        while(n &gt; 0){
            p = p-&gt;next;
            n--;
        }
        if(p == NULL){
            head = head-&gt;next;
            return head;
        }
        while(p-&gt;next != NULL){
            q = q-&gt;next;
            p = p-&gt;next;
        }
        r = q-&gt;next;
        if(r-&gt;next == NULL)
            q-&gt;next = NULL;
        else
            q-&gt;next = r-&gt;next;
        return head;
    }</code></pre>
<h5 id="23、合并K个排序链表-hard"><a href="#23、合并K个排序链表-hard" class="headerlink" title="23、合并K个排序链表(hard)"></a>23、合并K个排序链表(hard)</h5><p><em>题目描述：</em></p>
<p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc23.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>这道题目归为hard，其实并不难，属于一道综合问题。题目的基础是两个链表有序排列，由此引申出题目的解题方法有很多种，可以每次加入一个链表，直到全部加入其中，但这样做时间复杂度高。很容易地想到归并排序，将链表两两一组，2，4，8，16。。。逐渐完成全部的有序化，值得注意的是要对k的奇偶性做出讨论。同时我学到的还有在c++中，nullptr表示空指针。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        ListNode* res;
        int k = lists.size();
        if(lists.empty()){
            return nullptr;
        }
        else if(k == 1){
            return lists[0];
        }
        else{
            while(k &gt; 1){
                int count;
                if(k % 2){
                    count = k - 1;
                }
                else    
                    count = k;
                for(int i = 0; i &lt; count; i++){
                    lists[i/2] = mergetwo(lists[i], lists[i+1], lists);
                    i++;
                }
                if(k % 2){
                    lists[k/2] = lists[k-1];
                    k = k / 2 + 1;
                }
                else
                    k = k / 2;
            }
            return lists[0];
        }
    }
    ListNode* mergetwo(ListNode* l1, ListNode* l2, vector&lt;ListNode*&gt;&amp; lists) {
        ListNode* ans;
        ListNode* p;
        if(l1 == NULL &amp;&amp; l2 == NULL)
            return ans;
        else if(l1 != NULL &amp;&amp; l2 == NULL)
            return l1;
        else if(l1 == NULL &amp;&amp; l2 != NULL)
            return l2;
        if(l1-&gt;val &lt;= l2-&gt;val){
            ans = l1;
            l1 = l1-&gt;next;
            p = ans;
        }
        else{
            ans = l2;
            l2 = l2-&gt;next;
            p = ans;
        }
        while(l1 != NULL &amp;&amp; l2 !=NULL){
            if(l1-&gt;val &lt;= l2-&gt;val){
                p-&gt;next = l1;
                l1 = l1-&gt;next;
                p = p-&gt;next;
            }
            else{
                p-&gt;next = l2;
                l2 = l2-&gt;next;
                p = p-&gt;next;
            }
        }
        if(l1 != NULL){
            p-&gt;next = l1;
        }
        if(l2 != NULL){
            p-&gt;next = l2;
        }
        return ans;</code></pre>
<h5 id="25、-K-个一组翻转链表-hard"><a href="#25、-K-个一组翻转链表-hard" class="headerlink" title="25、 K 个一组翻转链表(hard)"></a>25、 K 个一组翻转链表(hard)</h5><p><em>题目描述：</em></p>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>说明：</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><em>示例：</em></p>
<p>给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p><em>思考：</em></p>
<p>我在这道题的实现中没有完成题目中常数额外空间的要求，而是模拟地将每k个节点先保存起来，再倒序链接起来。其实这里完全可以稍做修改，先确定剩下的节点是否有k个，再从开始处挨个倒转。当走到每个k个一组的最后一项时，再将上一组节点的第一项与其相连即可。若剩下的节点不足，则不进行变化。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == NULL)
            return head;
        ListNode* ans = new ListNode(-1);;
        ListNode* p;
        p = ans;
        vector&lt;ListNode*&gt; temp;
        int n = k;
        while(head != NULL){
            while(k){
                if(head == NULL)
                    break;
                else{
                    temp.push_back(head);
                }
                head = head-&gt;next;
                k--;
            }
            if(temp.size() &lt; n)
                break;
            else if(temp.size() == n){
                int i = n-1;
                while(!temp.empty()){
                    p-&gt;next = temp[i];
                    temp.pop_back();
                    p = p-&gt;next;
                    i--;
                }
            }
            k = n;
        }
        if(temp.empty())
            p-&gt;next = nullptr;
        else{
            for(int i = 0; i &lt; temp.size(); i++){
                p-&gt;next = temp[i];
                p = p-&gt;next;
            }
            p-&gt;next = nullptr;
        }
        return ans-&gt;next;
    }</code></pre>
<hr>
<h4 id="类别三：字符串的简单应用"><a href="#类别三：字符串的简单应用" class="headerlink" title="类别三：字符串的简单应用"></a><em>类别三：字符串的简单应用</em></h4><h5 id="3、无重复字符的最长子串-medium"><a href="#3、无重复字符的最长子串-medium" class="headerlink" title="3、无重复字符的最长子串(medium)"></a>3、无重复字符的最长子串(medium)</h5><p><em>题目描述：</em></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc3.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>题目要求取得不含重复字符的最长子串，我开始给出的方案就是按照从头到尾的顺序，依次作为子串开头，然后再进行一遍循环判断子串长度，当然我们这里判断是否出现了重复字符的手段为将<code>i</code>作为子串的最后一个字符，而将<code>p</code>指向子串的第一个字符，这样当向后遍历时，若出现重复可以通过<code>p = j+1</code>的手段减少<code>j</code>的循环次数。但毫无疑问，这个方法属于暴力解，时间复杂度达到了<em>O</em>（n^2）。那么有没有<em>O</em>（n）的时间复杂度呢？当然有，但同时代价是空间复杂度也达到了<em>O</em>（n）。方法就是依靠滑动窗口思想，并利用c++提供的关联容器<code>unordered_set</code>来进行存储已存在的字符，右指针通过不断读入新字符，当出现重复字符时，通过移动左指针来消除重复字符，由于<code>unordered_set</code>采用hash表进行查找，所以时间复杂度为<em>O</em>（1），则综合时间复杂度为<em>O</em>（n）。相关代码略。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">int lengthOfLongestSubstring(string s) {
        int l = s.length();
        if(l == 0)
            return 0;
        int p = 0;
        int max = 1;
        for(int i = 0; i &lt; l; i++){
            for(int j = p; j &lt; i; j++){
                if(s[j] == s[i]){
                    p = j + 1;
                }
            }
            int count = i - p + 1;
            if(count &gt; max)
                max = count;
        }
        return max;
    }</code></pre>
<h5 id="5、最长回文子串-medium"><a href="#5、最长回文子串-medium" class="headerlink" title="5、最长回文子串(medium)"></a>5、最长回文子串(medium)</h5><p><em>题目描述：</em></p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc5.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>回文串是算法题目中特别常见的题目，证明一个串是回文串的方法，既可以从两端向中间移动，也可以由中心向两端扩展，而为了减少重复判断的内容，显然后者更加适合判断回文串。这里有一点需要注意的是，由中心扩展存在两个问题，奇数中心与偶数中心，所以这两种情况均需要考虑。此时时间复杂度为<em>O</em>（n^2）。同时，此类题也有另外的解决办法，那就是动态规划，动态规划适合做什么样的题呢？就是可以把题目分隔开，假设字符串总长度100，那么我只要知道前99的结果，再把第100加入判断，就可以得到前100的结果。这就是数学归纳法的思想。由于本题目动态规划同样要用到一轮确定回文子串长度的遍历，加上总串的逐一遍历，时间复杂度同样为<em>O</em>（n^2），而空间复杂度由于要保存前面所有长度时的结果，同样达到了<em>O</em>（n^2），所有这里我们暂略。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">int ifcircle(string&amp; s, int i, int j){
        int L = i, R = j;
        if(s[L] != s[R])
            return 0;
        while(s[L] == s[R] &amp;&amp; L &gt; 0 &amp;&amp; R &lt; s.length()-1){
            L--;
            R++;
        }
        if(s[L] == s[R])
            return R - L + 1;
        else 
            return R - L - 1;
    }

    string longestPalindrome(string s) {
        int n = s.length();
        int len1, len2, len;
        int begin = 0, end = 0, max = 0;
        for(int i = 0; i &lt; n; i++){
            len1 = ifcircle(s, i, i);
            len2 = ifcircle(s, i, i+1);
            len = len1 &gt; len2 ?len1:len2;
            if(len &gt; max){
                if(len % 2){
                    begin = i - (len - 1)/2;
                    end = i + (len - 1)/2;
                }
                else{
                    begin = i - (len - 1)/2;
                    end = i + len / 2;
                }
                max = len;
            }
        }
        if(max % 2)
            return s.substr(begin, max);
        else
            return s.substr(begin, max);
    }</code></pre>
<h5 id="6、Z-字形变换-medium"><a href="#6、Z-字形变换-medium" class="headerlink" title="6、Z 字形变换(medium)"></a>6、Z 字形变换(medium)</h5><p><em>题目描述：</em></p>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为<code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>
<p>L    C      I      R<br>E T O E  S  I  I  G<br>E    D     H     N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p><code>string convert(string s, int numRows);</code></p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc6.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>本题看似是道字符串的重排列问题，但实际是一道数学题。根据给定的行数，我们来确定每次循环发生转折的字符长度为<code>temp = 2 * (numRows - 1)</code>，在此基础上通过建立对应的坐标转换关系，从而确定原字符串中每个字符对应新排列位置，再依次叠加各层字符得到新的字符串。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">string convert(string s, int numRows) {
        if(numRows == 1){
            return s;
        }
        int len = s.size();
        vector&lt;string&gt; rows(min(numRows, len));
        bool turn = false;
        int temp = 2 * (numRows - 1);
        for(int i = 0; i &lt; len; i++){
            int j = i % (temp);
            if(j &lt; numRows){
                rows[j] += s[i];
            }
            else if(j &gt;= numRows){
                rows[temp-j] += s[i];
            }
        }
        string ans;
        for (string row : rows) {// 从上到下遍历行
            ans += row;
        }
        return ans;
    }</code></pre>
<h5 id="10、正则表达式匹配-hard"><a href="#10、正则表达式匹配-hard" class="headerlink" title="10、正则表达式匹配(hard)"></a>10、正则表达式匹配(hard)</h5><p><em>题目描述：</em></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc10.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>这道题目是一道比较难的算法题，从题目来看，由于是对字符串匹配进行的一个判断，那么首先可以考虑到的就是动态规划和回溯算法。同时解决的手段可能并不限于递归、深度优先遍历。我在接触这道题目的时候对于回溯算法和动态规划还不够了解，无法做到应用，就采用了当时比较熟悉的递归进行的解答。递归解答的关键就是要确定递归的出口，这里我们确定出口应为s，p两个字符串均读到了最后一位。对于‘.’的匹配相对容易，只要将其作为任意字符即可。而对于‘*’字符来说，考虑的出发点主要在于零次与多次的区别。我的设计角度为设置more与zero的bool型变量，zero的判断依靠p字符串的后数两位字符确定<code>zero = pipei(s, p, x, y+2, len1, len2);</code>，而more的判断建立在非zero的前提下，<code>more = pipei(s, p, x+1, y, len1, len2);</code>。由于两种情况均可能，所以两者应为“或”的关系。值得一提的是，由于zero的判断式，我们存在x为len1-2，y为len2-2的情况，此时y+2为len2超出了边界条件。我的处理方式为在p字符串尾加入一个与所判断字符均不相同的字符（这里我加了”A”）。如果有时间可以用回溯或动态规划对题目重写。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">bool pipei(string&amp; s, string&amp; p, int x, int y, int len1, int len2){
        if(x == len1){
            if(y == len2){
                //cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;
                return true;
            }    

        }
        bool more = false, zero = false;
        if(p[y+1] == &#39;*&#39; &amp;&amp; y + 1 &lt; len2){
            zero = pipei(s, p, x, y+2, len1, len2);
            //cout &lt;&lt; x &lt;&lt; y &lt;&lt; zero &lt;&lt; more &lt;&lt; endl;
            if(zero == false &amp;&amp; (x &lt; len1) &amp;&amp; (s[x] == p[y] || p[y] == &#39;.&#39;)){
                more = pipei(s, p, x+1, y, len1, len2);
                //cout &lt;&lt; x &lt;&lt; y &lt;&lt; zero &lt;&lt; more &lt;&lt; endl;
            }
            return zero || more;
        }
        else{
            if((x &lt; len1) &amp;&amp; (s[x] == p[y] || p[y] == &#39;.&#39;)){
                //cout &lt;&lt; x &lt;&lt; y &lt;&lt; zero &lt;&lt; more &lt;&lt; endl;
                return pipei(s, p, x+1, y+1, len1, len2);
            }
            else{
                //cout &lt;&lt; x &lt;&lt; y &lt;&lt; zero &lt;&lt; more &lt;&lt; endl;
                return false;
            }
        }
        return false;

    }
    bool isMatch(string s, string p) {  
        int len1 = s.size();
        int len2 = p.size();
        p = p + &#39;A&#39;;
        bool ans = pipei(s, p, 0, 0, len1, len2);
        return ans;
    }</code></pre>
<h5 id="30、串联所有单词的子串-hard"><a href="#30、串联所有单词的子串-hard" class="headerlink" title="30、串联所有单词的子串(hard)"></a>30、串联所有单词的子串(hard)</h5><p><em>题目描述：</em></p>
<p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc30.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>本题给出的解决方法，是基于哈希表的匹配查找机制。思路很简单，由于子串长度为<code>wid*W</code>，那么外层循环的范围应该为<code>for(int i = 0; i &lt;= len-wid*W; i++)</code>，而对于每次循环，都一一对由<code>words</code>中所有元素组成的哈希表进行比对，若比对成功则满足输出条件，输出此时的<code>i</code>。本题思路清晰，不过当字符串总长度很长时，循环幅度很大，而从原字符串中截取<code>word</code>大小的子字符串也花费很多时间，总的来说时间复杂度还是偏高的。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; ans;
        int len = s.size();     //特殊情况 
        if(len == 0)
            return ans;
        int wid = words.size();
        if(wid == 0)
            return ans;
        int W = words[0].size();
        if(W == 0)
            return ans;
        if(len &lt; wid*W)
            return ans;
        unordered_map&lt;string, int&gt; bz;
        unordered_map&lt;string, int&gt; temp;
        for(string t:words)
            bz[t]++;
        for(int i = 0; i &lt;= len-wid*W; i++){
            temp = bz;
            int j = 0;
            while(j &lt; wid){
                string xyz = s.substr(i+j*W, W);
                if(temp[xyz] &gt; 0)
                    temp[xyz]--;
                else
                    break;
                j++;
            }
            if(j == wid)
                ans.push_back(i);
        }
        //sort(ans.begin(), ans.end());
        return ans;
    }</code></pre>
<hr>
<h4 id="类别四：二分查找的应用"><a href="#类别四：二分查找的应用" class="headerlink" title="类别四：二分查找的应用"></a><em>类别四：二分查找的应用</em></h4><h5 id="4、寻找两个有序数组的中位数-hard"><a href="#4、寻找两个有序数组的中位数-hard" class="headerlink" title="4、寻找两个有序数组的中位数(hard)"></a>4、寻找两个有序数组的中位数(hard)</h5><p><em>题目描述：</em></p>
<p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 <code>nums1</code>和 <code>nums2</code>不会同时为空。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc4.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>找中位数的题目也是算法中特别常见的，依据其是否有序，可以考虑应用二分查找。本题目要求时间复杂度为<em>O</em>(log(m + n))，那么就必须从二分查找入手考虑问题。（当然还有堆排序、分治算法的方式可能满足O(log(m + n))）不失一般性的，我们可以让短数组为<code>nums1</code>，长数组为<code>nums2</code>（其实无影响），为了最小化时间复杂度，我们考虑这样的情况，一定存在<code>half = (m + n + 1)/2</code>个元素比中位数小的情况。基于这个情况，我们在短数组中计算一个中位数<code>mid1 = (a1 + a2)/2</code>，再在长数组中计算一个<code>mid2 = half - mid1</code>，后续通过两个位置<code>nums1[mid1]</code>，<code>nums2[mid2-1]</code>处的数值大小比较，进而确定中位数在<code>nums1</code>数组中的位置关系，这样的判断方法可以在O(logm）中完成对<code>nums1</code>的数据筛查。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        if(nums1.size() &gt; nums2.size())
            return findMedianSortedArrays(nums2, nums1);
        int m = nums1.size();
        int n = nums2.size();
        int a1 = 0, a2 = m;
        int mid1, mid2, half = (m + n + 1)/2;
        while(a1 &lt;= a2){
            mid1 = (a1 + a2)/2;
            mid2 = half - mid1;
            if(mid1 &lt; a2 &amp;&amp; nums2[mid2-1] &gt; nums1[mid1]){
                a1 = mid1 + 1;
            }
            else if(mid1 &gt; a1 &amp;&amp; nums1[mid1-1] &gt; nums2[mid2]){
                a2 = mid1 - 1;
            }
            else{
                int maxl = 0;
                if(mid1 == 0)
                    maxl = nums2[mid2-1];
                else if(mid2 == 0)
                    maxl = nums1[mid1-1];
                else{
                    maxl = nums1[mid1-1] &gt; nums2[mid2-1] ?nums1[mid1-1]:nums2[mid2-1];
                }
                if((m + n) % 2 == 1)
                    return maxl;
                int maxr = 0;
                if(mid1 == m)
                    maxr = nums2[mid2];
                else if(mid2 == n)
                    maxr = nums1[mid1];
                else
                    maxr = nums1[mid1] &lt; nums2[mid2] ?nums1[mid1]:nums2[mid2];
                return (maxl + maxr) / 2.0;
            }
        }
        return 0.0;
    }</code></pre>
<hr>
<h4 id="类别五：边界条件的考察"><a href="#类别五：边界条件的考察" class="headerlink" title="类别五：边界条件的考察"></a><em>类别五：边界条件的考察</em></h4><h5 id="8、字符串转换整数-atoi-medium"><a href="#8、字符串转换整数-atoi-medium" class="headerlink" title="8、字符串转换整数 (atoi)(medium)"></a>8、字符串转换整数 (atoi)(medium)</h5><p><em>题目描述：</em></p>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc8.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>本题目是属于不难但分析起来特别恶心的那种，由于存在各种各样的边界情况，需要分开讨论。关于字符向数字转变可以由<code>str[i] - &#39;0&#39;</code>实现。其他需要注意的点为：1、不仅“-”可以成为数字开头，“+”同样可以。2、数字在超越整数边界条件的判断（2147483647，-2147483648）。我在当时完成题目时对结果的判断用到了很多bool型，同时存在很多命名问题，使得在后续回顾时对于判断条件云里雾里，这样做存在很大弊端，各位不要学我。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">int myAtoi(string str) {
        int len = str.size();
        int i = 0, num = 0;
        bool flag = false;
        bool count1 = false;
        bool count2 = false;
        bool big = false;
        bool number = false;
        int n = 0;
        while(i &lt; len){
            if(str[i] == &#39; &#39;){
                if(flag == false &amp;&amp; count1 == false &amp;&amp; count2 == false &amp;&amp; number == false)
                    n++;
                else
                    break;
            }
            else if(str[i] == &#39;-&#39;){
                if(flag == false &amp;&amp; count1 == false &amp;&amp; count2 == false &amp;&amp; number == false){      //防止遇到-25-566的情况
                    flag = true;
                    count1 = true;
                }
                else
                    break;
            }
            else if(str[i] == &#39;+&#39;){
                if(flag == false &amp;&amp; count1 == false &amp;&amp; count2 == false &amp;&amp; number == false){      
                    count2 = true;
                }
                else
                    break;
            }
            else if(str[i]&gt;=&#39;0&#39;&amp;&amp;str[i]&lt;=&#39;9&#39;){
                number = true;
                if(flag == true &amp;&amp; count1 == true &amp;&amp; count2 == false){
                    num = 0 - (str[i] - &#39;0&#39;);
                    count1 = false;
                }
                else if((((num == INT_MAX/10) &amp;&amp; (str[i] - &#39;0&#39; &lt;= 7)) || (num &lt; INT_MAX/10))&amp;&amp;(flag == false)){
                    num = num * 10;
                    num = num + (str[i] - &#39;0&#39;);
                }
                else if((((num == INT_MIN/10) &amp;&amp; (str[i] - &#39;0&#39; &lt;= 8)) || (num &gt; INT_MIN/10))&amp;&amp;(flag == true)){
                    num = num * 10;
                    num = num - (str[i] - &#39;0&#39;);
                }
                else 
                    big = true;  
             }
            else
                break;
            i++;
        }
        if(num){
            if(big &amp;&amp; !flag)
                return INT_MAX;
            else if(big &amp;&amp; flag)
                return INT_MIN;
            else
                return num;
        }
        else 
            return 0;
    }</code></pre>
<h5 id="29、两数相除-medium"><a href="#29、两数相除-medium" class="headerlink" title="29、两数相除(medium)"></a>29、两数相除(medium)</h5><p><em>题目描述：</em></p>
<p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 <code>mod</code>运算符。</p>
<p>返回被除数 <code>dividend</code> 除以除数<code>divisor</code>得到的商。</p>
<p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code>。</p>
<p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc29.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>跟边界条件有关，这又是一道繁琐的题目。我对这道题边界条件的分析，更多地就是采取一种枚举的分析方式。首先就是<code>INT_MIN</code>除以<code>-1</code>会产生越界，其次，我通过<code>flag1</code>和<code>flag2</code>分别作为判断被除数和除数的符号位正负性的标志位。而对于<code>INT_MIN</code>越界的问题，我通过设置<code>change</code>标志位来将其转化为<code>INT_MAX</code>进行计算。由于题目要求我们不能用除法、乘法和<code>mod</code>运算符，所以解决除法运算的关键在于位运算，从被除数二进制数的最高位逐渐剥离，直到其小于除数，这样循环累加就能得到商。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">int divide(int dividend, int divisor) {
        if(dividend == INT_MIN &amp;&amp; divisor == -1)
            return INT_MAX;
        if(dividend == INT_MIN &amp;&amp; divisor == 1)
            return INT_MIN;
        if(dividend == INT_MIN &amp;&amp; divisor == INT_MIN)
            return 1;
        if(dividend &gt; INT_MIN &amp;&amp; divisor == INT_MIN)
            return 0;
        bool flag1 = false;
        bool flag2 = false;
        bool change = false;
        if(dividend == INT_MIN){
            dividend = INT_MAX;
            change = true;
            flag1 = true;
        }
        if(dividend &lt; 0){
            dividend = 0 - dividend;
            flag1 = true;
        }
        if(divisor &lt; 0){
            divisor = 0 - divisor;
            flag2 = true;
        }
        if(dividend &lt; divisor)
            return 0;
        int count = 0;
        while(dividend &gt;= divisor){
            int temp = divisor;
            int temp_count = 1;
            while((dividend &gt;= (temp &lt;&lt; 1)) &amp;&amp; (temp &lt; INT_MAX/2)){
                temp = temp &lt;&lt; 1;
                temp_count = temp_count &lt;&lt; 1;
            }
            dividend = dividend - temp;
            count = count + temp_count;
        }
        if(change){
            dividend++;
            if(dividend == divisor)
                count++;
        }
        if((flag1 &amp;&amp; flag2) || (!flag1 &amp;&amp; !flag2))
            return count;
        else 
            return 0 - count;
    }</code></pre>
<hr>
<h4 id="类别六：回溯算法的应用"><a href="#类别六：回溯算法的应用" class="headerlink" title="类别六：回溯算法的应用"></a><em>类别六：回溯算法的应用</em></h4><h5 id="17、电话号码的字母组合-medium"><a href="#17、电话号码的字母组合-medium" class="headerlink" title="17、电话号码的字母组合(medium)"></a>17、电话号码的字母组合(medium)</h5><p><em>题目描述：</em></p>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc17-A.png" srcset="/img/loading.gif" alt></p>
<p><em>示例：</em></p>
<p><img src="/2020/03/24/%E7%9A%AE%E5%8D%A1%E4%B8%98422%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/lc17-B.png" srcset="/img/loading.gif" alt></p>
<p><em>思考：</em></p>
<p>本题是一道经典的回溯问题，何谓回溯，就是我试着走，走错了再反悔就是了。关键步骤就是在尝试与撤销中。如果尝试成功，那么我就继续试，直到得到答案；如果尝试失败，我就撤销这次尝试，更换新的尝试。回溯算法适合输出多组满足条件的集合值。本题中依靠数字来映射不同的字母，就完美符合回溯思想，映射完一项映射下一项，直到全部映射完毕。</p>
<p><em>最终代码</em></p>
<pre><code class="c++">vector&lt;string&gt; letterCombinations(string digits) {
        vector&lt;string&gt; ans;
        vector&lt;string&gt; number = {
            &quot;abc&quot;,&quot;def&quot;,
            &quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,
            &quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;
        };
        vector&lt;int&gt; num;
        int len = digits.size();
        if(len == 0)
            return ans;
        for(int i = 0; i &lt; len; i++){
            num.push_back(digits[i] - &#39;2&#39;);
        }
        string s;
        backtrack(len, 0, s, ans, number, num);
        sort(ans.begin(), ans.end());
        return ans;
    }

    void backtrack(int len, int n, string &amp;s, vector&lt;string&gt; &amp;ans, vector&lt;string&gt; &amp;number, vector&lt;int&gt; &amp;num){
        if(n == len){
            ans.push_back(s);
            return;
        }
        int count = number[num[n]].size();
        for(int j = 0; j &lt; count; j++){
            s.push_back(number[num[n]][j]);
            backtrack(len, n+1, s, ans, number, num);
            s.pop_back();  
        }
    }</code></pre>
<hr>
<h4 id="类别四：二分查找的应用-1"><a href="#类别四：二分查找的应用-1" class="headerlink" title="类别四：二分查找的应用"></a><em>类别四：二分查找的应用</em></h4><h5 id="4、寻找两个有序数组的中位数-hard-1"><a href="#4、寻找两个有序数组的中位数-hard-1" class="headerlink" title="4、寻找两个有序数组的中位数(hard)"></a>4、寻找两个有序数组的中位数(hard)</h5><p><em>题目描述：</em></p>
<p><em>示例：</em></p>
<p><em>思考：</em></p>
<p><em>最终代码</em></p>

            </div>
            <hr>
            <div>
              <p>
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0/">算法的学习</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/03/25/c++%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92%E2%80%94%E2%80%94%E9%9A%BE%E9%A2%98%E9%94%99%E9%A2%98%E7%AF%87/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">c++从零单排——难题错题篇</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>








<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "皮卡丘422的第一篇个人博客&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
